

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="https://s4.ax1x.com/2021/12/22/TQjIaQ.png">
  <link rel="icon" href="https://s4.ax1x.com/2021/12/22/TQjIaQ.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="wty">
  <meta name="keywords" content="">
  
    <meta name="description" content="使用vjudge进行题目评测，减少找题的工作量。  ~&#x2F;.vimrc 中g++使用F5快速执行代码， autocmd filetype cpp nnoremap &lt;F5&gt; :w &lt;bar&gt; !g++ % -o %:r &amp;&amp; .&#x2F;%:r&lt;CR&gt;  2023.4月  2023.4.24. 《第一章 算法设计基础》  UVA - 11292">
<meta property="og:type" content="article">
<meta property="og:title" content="2023算法复习">
<meta property="og:url" content="https://wty-yy.xyz/posts/35639/index.html">
<meta property="og:site_name" content="wty&#39;s blog">
<meta property="og:description" content="使用vjudge进行题目评测，减少找题的工作量。  ~&#x2F;.vimrc 中g++使用F5快速执行代码， autocmd filetype cpp nnoremap &lt;F5&gt; :w &lt;bar&gt; !g++ % -o %:r &amp;&amp; .&#x2F;%:r&lt;CR&gt;  2023.4月  2023.4.24. 《第一章 算法设计基础》  UVA - 11292">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wty-yy.xyz/figures/ACM/72.SPOJ-BEADS-Glass_Beads.jpg">
<meta property="article:published_time" content="2023-05-07T15:28:00.000Z">
<meta property="article:modified_time" content="2024-05-24T03:17:58.040Z">
<meta property="article:author" content="wty">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://wty-yy.xyz/figures/ACM/72.SPOJ-BEADS-Glass_Beads.jpg">
  
  
  
  <title>2023算法复习 - wty&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/prism/1.26.0/plugins/line-numbers/prism-line-numbers.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.15.2/katex.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/fold_code.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_3429772_kq6ntj4nzdo.css">
<link rel="stylesheet" href="//fastly.jsdelivr.net/gh/bynotes/texiao/source/css/toubudaziji.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"wty-yy.xyz","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":"843a38ffdc8864dd30e250b723a1a8ca","google":null,"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null},"gtag":null,"woyaola":null,"cnzz":null},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Home</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-books"></i>
                <span>文档</span>
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/posts/18857/" target="_self">
                    
                    <span>模板&dotfiles</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/posts/64648/" target="_self">
                    
                    <span>常用命令及函数</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/posts/57899/" target="_self">
                    
                    <span>算法总结</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/posts/20023/" target="_self">
                    
                    <span>Linux杂记</span>
                  </a>
                
              </div>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://s4.ax1x.com/2021/12/22/TQOxyT.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="2023算法复习"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-05-07 23:28" pubdate>
          2023年5月7日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          21k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          179 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">2023算法复习</h1>
            
              <p id="updated-time" class="note note-info" style="">
                
                  
                    <!-- compatible with older versions-->
                    最新更新于: 2024年5月24日上午11点17分
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>使用<a target="_blank" rel="noopener" href="https://vjudge.net">vjudge</a>进行题目评测，减少找题的工作量。</p>
</blockquote>
<p><code>~/.vimrc</code> 中g++使用F5快速执行代码，</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-vimrc" data-language="vimrc"><code class="language-vimrc">autocmd filetype cpp nnoremap &lt;F5&gt; :w &lt;bar&gt; !g++ % -o %:r &amp;&amp; .&#x2F;%:r&lt;CR&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>
<h4 id="20234月"><a class="markdownIt-Anchor" href="#20234月"></a> 2023.4月</h4>
<h5 id="2023424"><a class="markdownIt-Anchor" href="#2023424"></a> 2023.4.24.</h5>
<p>《第一章 算法设计基础》</p>
<ol>
<li>UVA - 11292 - Dragon of Loowater 贪心，双指针</li>
<li>UVA - 11729 - Commando War 贪心<br />
证明贪心的正确性，基于一个先假设好的条件，分类讨论结果，比较结果的正确性，使用 (Job){a, b} 对结构体赋予初值</li>
<li>UVA - 11300 - Spreading the Wealth 思考题<br />
将题目中的变量设出来，得到n个变量和n-1个方程的方程组组，通过其中一个变量x1将其他变量表示出来，再将目标最小化结果由单变量表示出来，发现是一个一维绝对值之和最小化问题，取中位数即可（反证法证明）</li>
<li>CF Gym NEERC 2006 - 100287G - Graveyard 贪心<br />
非常具有技巧性的题目，首先阅读题目有些难度，主要要注意到equidistant和memorial两个含义，首先用到<strong>等距缩放</strong>的技巧，并对雕像进行<strong>编号</strong>，这样就能把圆上的问题转化为一维整数点区间上的问题，并用贪心进行求解非常巧妙：将加入新雕像后的坐标作为整数坐标，总距离为(n+m)，就雕像位置在该坐标尺度下表示出来（小数形式），再将每个雕像移动到最近的整点坐标即可(四舍五入)，最后再证明贪心的正确性。</li>
<li>UVA - 10881 - Piotr’s Ants 思路题<br />
蚂蚁碰头之后会反向移动，容易发现一点是蚂蚁之间的相对位置是不会变换的，最重要解题点是将蚂蚁的碰头视为相互穿过。<br />
于是只需先假设蚂蚁是相互穿过的，然后再排序得到相对顺序，再通过初始的相对顺序order[i]，最终根据相对序号的一致性，得到每个编号的蚂蚁的最终位置。<br />
注：数轴长度为L，并从0开始。</li>
<li>UVA - 1030 - Image Is Everything 暴力模拟题<br />
题目要求最大的正方体方块个数，也就是挖去所有产生矛盾的方块，剩下的非空方块个数就是最大个数，所以只需要找出所有一定有矛盾的方块：
<ol>
<li>如果某个视图上为 <code>'.'</code> 则全部深度的方块均为空。</li>
<li>暴力枚举<strong>每个视图上的每个位置的所有深度</strong>，对立方体建立坐标系，定义函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>视图相对坐标+深度</mtext><mo>↦</mo><mtext>立方体方格坐标</mtext></mrow><annotation encoding="application/x-tex">\text{视图相对坐标+深度}\mapsto \text{立方体方格坐标}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord text"><span class="mord cjk_fallback">视图相对坐标</span><span class="mord">+</span><span class="mord cjk_fallback">深度</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">立方体方格坐标</span></span></span></span></span>，判断当前方格的颜色是否和当前视图中的颜色一致，如果一致则跳过后续深度枚举，否则将其挖去，继续枚举后续深度。</li>
</ol>
</li>
</ol>
<ul>
<li>技巧：
<ul>
<li>利用宏函数 <code>#define rep(i, n) for (int i = 0; i &lt; n; i++)</code> 可以大幅减少 <code>for</code> 循环的冗余，使代码更加简洁易读。</li>
<li>对于多个返回值的函数，无需对其进行返回，而是使用传递实参的方式进行返回。</li>
</ul>
</li>
</ul>
<ol start="7">
<li>Codeforces Round 867 (Div. 3)<br />
比较简单的比赛，但是由于不理解题意没有打好。看复杂题面的题，首先找题目求解的问题关键词：Answer, You need, Formally … ，再通过题目给出的样例进一步分析题意，最后确定有哪些变量需要开 <code>long long</code>
<ol>
<li>两道题，没有仔细开 <code>long long</code> 导致错误提交，也就是思路还不够清晰。</li>
<li>F题，树的边数组开小了1个，树上dp找每个节点u第一和第二长的路径 <code>mx[u][0]</code> 和<code>mx[u][1]</code>，只需两次dfs，固定一个节点为根节点，第一次dfs求出每个节点到叶子节点的第一二大的距离，并存储下最大距离是从 <code>frome[u]</code> 节点转移得到的，第二次dfs可得每个节点上方的最大距离（注意如果是递推到 <code>from[u]</code> 节点则其最大距离为 <code>max(rtlen, mx[u][1] + 1)</code>）。</li>
<li>D题，容易想到不是解的必要条件：n&gt;1且为奇数则一定不是解；还是考虑构造从而得出其充分性，首先a的第一个一定是n，构造的技巧是利用每个元素的范围有限[1,n)，保持构造的结果具有某种递增的规律（围绕某个元素进行构造），在模意义下构造出a=[1,-2,3,-4,5,-6,…,-(n-2),n-1]。</li>
</ol>
</li>
</ol>
<h5 id="2023425"><a class="markdownIt-Anchor" href="#2023425"></a> 2023.4.25.</h5>
<ol start="8">
<li>UVA - 11464 - Even Parity 暴力<br />
通过每个点四周必定为偶数个黑点，如果确定了前两排的结果，那么第三排的状态就可以唯一确定了，所以我们只需要暴力枚举第一排，于是之后的每一排都唯一确定了（一个十字架，上面三个顶点的值确定，总和为偶数，那么下面的值一定可以确定下来）</li>
<li>UVA - 1352 - Colored Cubes 暴力<br />
首先对正方体进行编号，枚举正方体的全部旋转方法24种，打表；然后对实际的5个正方体逐个枚举旋转方法，复杂度为O(24^3)，对于每个面，全部染为有最多共同颜色的面，取最小的染色方法。<br />
注：能不用 <code>#include &lt;bits/stdc++.h&gt;</code> 就不要使用，会大幅度降低编译速度，并且有变量重名的可能。</li>
<li>UVA - 11210 - Chinese Mahjong 暴力<br />
麻将题，注意枚举顺序：依次枚举听牌，将牌，刻子和顺子。灵活运用 <code>string</code> 数据类型进行牌型判断，用<code>s.c_str()</code> 转为 <code>char*</code> 输出 <code>string</code> 类型；注意输出结果的空格细节。</li>
<li>UVA - 11384 - Help is needed for Dexter 简单题<br />
非常简单，找到规律就是log2n向下取整+1</li>
<li>UVA - 10795 - A Different Task 数学题<br />
巧妙的利用了汉诺塔的性质，一定要移动的一定是最大的终止状态和初始状态不同的大小为k的圆盘，所以一定要把1…k-1移动到唯一多余的柱子上这个状态成为中间状态，利用移动圆盘的对称性，只需将初始和终止两个状态的圆盘都移动到该中间状态上，再+1就得到答案了。<br />
巧妙的构造递归函数f(P, i, final)，这和dp类似，P表示开始状态，i表示最大的圆盘，final是将1…i-1圆盘全部移动到final柱子上，递推方法也是类似的思路，看最大的圆盘位置有没有移动，如果<code>final[i]!=P[i]</code>，说明1…i-1都要先移动到<code>6-final[i]-P[i]</code>上，然后将1…i-1移动回final[i]，这一步就是传统的汉诺塔，直接给出步数<code>2^(i-1)=1+2+...+2^(i-2)</code>。</li>
</ol>
<h5 id="2023426"><a class="markdownIt-Anchor" href="#2023426"></a> 2023.4.26.</h5>
<ol start="13">
<li>
<p>UVA - 12124 - Assemble 二分答案<br />
最小值最大问题，显然二分答案，利用结构体存储每个类型的物品，注意到结果中没有涉及到部件的名称，所以无需存储名称。</p>
<p>注意：<strong>使用下标枚举vector中的数据</strong>，而不是使用速度慢的 <code>for (auto x : v)</code>（慢20倍左右）。</p>
</li>
<li>
<p>CF Gym NWERC 2006 - 100722C - Pie 二分答案<br />
非常简单，只需二分枚举派的大小即可。使用 <code>const double PI = acos(-1.0)</code> 定义PI。</p>
</li>
<li>
<p>UVA - 11520 - Fill the Square 暴力枚举<br />
非常简单，从小到大枚举字符即可。</p>
<p>注意：<strong>字符串数组必须至少为最大字符串长度+1</strong>，因为有终止符 <code>0</code> 存在。</p>
</li>
<li>
<p>UVA - 1267 - Network 贪心<br />
贪心地每次从距离根服务器最远的节点开始向上找最远的祖先节点放置服务器镜像，注意使用链表从边的编号从0开始存图每次要初始化所有的 <code>head[u]=0</code>，并初始化 <code>ecnt=0</code>。</p>
</li>
<li>
<p>UVA - 1335 - Beijing Guards 二分答案，巧妙的贪心判断结果<br />
求解环形问题第一步一定是确定基准元，然后<strong>分析二分的上下界</strong>（非常重要，一定要想清楚），下界一定是两个相邻的礼物需求之和的最大值，上界是最大礼物需求的三倍；最巧妙的是，贪心判断是否可行时，顺次贪心选取的礼物数量只不过方向正好相反，第0个从左开始选r[0]个，第1个也从左选r[0]个，第2个从右选r[0]个，最后判断n-1个从右选的r[n-1]个是否和第0个选的r[0]个重复；但是这样检查一次的复杂度是O(n^2)，注意到题目没有要求具体礼物的编号，并且我们只关心第n-1和第0个人是否选取重复，所以可以以<strong>第0个选取的礼物将全部礼物划分为左右两部分</strong>，后面的每个人只需考虑在两个部分中各选了多少个即可，最后判断最后一个人有没有在左边选取礼物即可。<br />
注意：</p>
<ol>
<li>二分的上下界分析（必要性），对于判断函数 <code>check()</code> 也可以缩小判断范围。</li>
<li>边界条件n=1的判断。</li>
<li>二分答案的两种写法：</li>
</ol>
</li>
</ol>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> L<span class="token punctuation">,</span> R<span class="token punctuation">;</span>
<span class="token comment">// 最小化二分</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>L <span class="token operator">&lt;</span> R<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>L <span class="token operator">+</span> R<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span> R <span class="token operator">=</span> mid<span class="token punctuation">;</span>  <span class="token comment">// 如果mid可行</span>
    <span class="token keyword">else</span> L <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 最大化二分</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>L <span class="token operator">&lt;</span> R<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>L <span class="token operator">+</span> R <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span> L <span class="token operator">=</span> mid<span class="token punctuation">;</span>  <span class="token comment">// 如果mid可行</span>
    <span class="token keyword">else</span> R <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 两种写法二分结果均为L</span>
<span class="token keyword">return</span> L<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<ol start="18">
<li>UVA - 11462 - Age Sort 桶排序<br />
没什么技巧，只需注意末尾不要有多余空格。</li>
<li>UVA - 11078 - Open Credit System 贪心，简单题</li>
</ol>
<h5 id="2023427"><a class="markdownIt-Anchor" href="#2023427"></a> 2023.4.27</h5>
<ol start="20">
<li>UVA - 11549 - Calculator Conundrum 暴力<br />
利用Floyd判圈算法通过两个节点的运动速度不同（一个运动速度为1，另一个为2），从而在O(n)时间下找大小为n的环。</li>
<li>UVA - 1398 - Meteor - E4 代数几何，线段最大交集<br />
仅考虑<strong>对答案产生贡献</strong>的时间段，用结构题存储区间的端点，由于每个时间段均为开集，在用扫描线处理到相同位置的边界点时，优先处理右端点（如果是闭集则优先处理左端点）</li>
<li>UVA - 1330 - City Game - E1 代数几何，最大化矩形面积<br />
考虑点(i,j)向上扩展出的最大距离记为up(i,j)，向左右按照上方最大距离能扩展的最大距离分别记为left(i,j),right(i,j)，于是这个点按照向上最大距离能扩展的最大面积为<code>(right(i,j)-left(i,j)+1)*up(i,j)</code>。<br />
进一步考虑用迭代方式求解这三个数组，不难发现<code>up(i,j)=up(i-1,j)</code>，顺次从上到下，以横向扫描线扫描没一行，从左到右更新left，如果<code>up(i-1,j)&lt;up(i,j)</code>则<code>left(i,j)=1</code>，否则<code>left(i,j)=left(i-1,j)</code>；right数组从右到左更新，方法类似。</li>
<li>UVA - 1382 - Distant Galaxy - E1 代数几何，最大化矩形边界点<br />
找矩形上一定存在的条件：每条边上至少有一个点，于是转化为通过点枚举边，枚举四条边有点多了，所以就枚举上下两条边（按照y轴枚举，需要对y轴进行排序，顺便去重，方便枚举），然后找再两条矩形的竖线构造出矩形，现在考虑如何快速求出最大的边界点，首先考虑矩形的边界点可以通过哪些变量求出，left[i],on[i],on2[i]分别表示第i个竖线左侧在上下两边上的点数目（不包括i）、第i个竖线上夹在上下两边中间的点数（不包括两边）、第i个竖线上夹在上下两边中间的点数（包括两边），于是第i,j竖线构成的矩形上的点可以表示为<code>left[j]-left[i]+on2[j]+on[i]</code>，求(i,j)使得递推式最大化，可以从左至右顺次枚举，记录下<code>on[i]-left[i] (i&lt;j)</code>的最大值mx，于是<code>left[j]+on2[j]+mx</code>就是矩形右直线为j能覆盖的最大点数。</li>
<li>UVA - 10755 - Garbage Heap - E1 代数几何，容斥原理<br />
先从求二维面积最大矩形权重之和考虑，通过维护前缀和，枚举矩形边界y1,y2，再从小到大枚举x，通过前缀和求出{(1,y1),(x,y2)}的权重之和，记录下前面扫描过的最小值，则最大权重是当前的权重之和减去之前的最小值。<br />
三维方法类似，主要是怎么求出前缀和，考虑二位的容斥原理，每次要求出{(x1,y1),(x2,y2)}的面积，就是通过s(x1,y1)减去s(x1,y2)和s(x2,y1)的并，这个并可以通过容斥原理得到：s(x1,y2)+s(x2,y1)-s(x2,y2)<br />
类似的三维也是通过s(x1,y1,z1)减去s(x2,y1,z1),s(x1,y2,z1),s(x1,y1,z2)的并，通过容斥原理可得：s(x2,y1,z1)+s(x1,y2,z1)+s(x1,y1,z2)-s(x2,y2,z1)-s(x2,y1,z2)-s(x1,y2,z2)+s(x2,y2,z2)<br />
最后也是枚举六面体边界x1,x2,y1,y2，再从小到大枚举z，与二位相似的操作即可求出三维权重最大值。</li>
<li>CF Gym - 101388J - Jurassic Remains - E0 位运算，折半枚举<br />
难度最大的是读懂这个题目，题目说是要骨头配对，其实就是骨头上关节的编号配对，也就是每个编号至少能有一对，也就是每个字母出现的次数一定要是偶数次，所以可以想到用异或运算解决。<br />
由于编号只有26种，骨头数目也不超过26个，先将骨头的编号转为对应的二进制位，一个集合中所有骨头的编号异或起来如果是0则满足题意，再通过折半枚举，先枚举n/2个骨头的所有编号组合，并用map的key值记录编号组合，value值记录选择的骨头（相同则取骨头集合中元素最多的），然后在枚举另一半的所有骨头编号组合，判断是否在map中有对应的key值即可，复杂度<code>O(2^(n/2)log(2^(n/2)))=O(n/2*2^(n/2))</code>。</li>
</ol>
<h5 id="2023429-算法复习计划1"><a class="markdownIt-Anchor" href="#2023429-算法复习计划1"></a> 2023.4.29. 算法复习计划1</h5>
<ul>
<li>[x] DP平行四边形不等式优化、单调队列优化</li>
<li>[x] Trie</li>
<li>[x] KMP</li>
<li>[x] 线段树</li>
<li>[x] SA <code>2023.5.17.</code></li>
<li>[x] SAM</li>
<li>[ ] Tarjan</li>
<li>[ ] 二分图匹配</li>
</ul>
<h5 id="2023430-初步学习四边形不等式dp优化"><a class="markdownIt-Anchor" href="#2023430-初步学习四边形不等式dp优化"></a> 2023.4.30. 初步学习四边形不等式DP优化</h5>
<ol start="25">
<li>洛谷 - P3515 - Lightning Conductor 平行四边形不等式DP优化-1<br />
要求 <code>p[i] = max&#123;h[j]-h[i]+sqrt(abs(i-j)) : 1&lt;=j&lt;=n&#125;</code>，先转化为 <code>min</code> 问题，然后发现极小化函数为 <code>h[i]-h[j]-sqrt(abs(i-j))</code> 记极小值为 <code>f[i]</code>，通过分类讨论可以把绝对值去掉 <code>abs(i-j)=i-j, i &gt; j</code>，只要注意到 <code>-h[j]+h[i]</code>，<code>i-j</code> 都满足平行四边形恒等式，且 <code>-sqrt(x)</code> 为凸函数，所以 <code>-sqrt(i-j)</code> 满足平行四边形不等式，故 <code>f[i]</code> 最优决策 <code>k[i]</code> 单调递增，可以使用分治法求解。<br />
技巧：由于要讨论 <code>i&lt;j</code> 和 <code>j &gt; i</code> 两种情况，所以可以通过将数组 <code>h, f</code> 进行反转后，用同一个DP分治函数即可实现两种情况。</li>
<li>POJ - 2823 - Sliding Window 连续区间最值RMQ查询，单调队列<br />
经典单调队列例题，滑动窗口区间最值查询写为数学表达式就是 <code>f[r] = max&#123;a[l] : r-k&lt;l&lt;=r&#125;</code>，单调队列可以实现处理极大极小值问题时，当决策空间在状态域上具有单调性，则可以通过从小到大枚举状态值 <code>r</code>，并用单调队列维护当前可行的最优解即可。复杂度O(n)。</li>
<li>洛谷 - P2698 - Flowerpot S 连续区间最值查询，单调队列<br />
本题中区间长度未知，要求求出最小的区间长度 <code>len</code> 使得存在 <code>r-l=len</code> 有 <code>max A[j] - min A[j] &gt;= d</code> 成立（分别取区间最大值和最小值），首先可以二分答案，用单调队列check，复杂度O(nlogn)；然而这题有不用二分答案的方法，要发现当固定左端点 <code>l</code> 时，目标函数是关于右端点 <code>r</code> 单增的，所以如果 <code>[l,r]</code> 满足题意，则 <code>[l,r+1]</code> 也能满足题意，也就是最小的满足题意的 <code>r</code> 就是我们要求的最小长度，所以可以枚举 <code>r</code>，每次区间 <code>[l,r]</code> 满足题意，逐步增加 <code>l</code> 直到不再满足题意为止，中间记录下最小值就是答案，复杂度O(n)。</li>
<li>CodeForces - 372C - Watching Fireworks is Fun 单调队列优化DP<br />
本题是1D1D型DP，<code>f(i,j) = max&#123;f(i-1,k):|k-j|&lt;=d*(t[i]-t[i-1])&#125;+b[i]-|a[i]-j|</code>，注意到更新区间 <code>[j-d*(t[i]-t[i-1]), j+d*(t[i]-t[i-1])]</code> 是随j连续变换的，所以可以直接用单调队列维护 <code>max&#123;f(i-1,k)&#125;</code>。<br />
注意：循环区间条件的成立性，要将 <code>pop_front</code> 放在 <code>pop_back</code> 循环外，否则有时候不进入循环则无法执行 <code>pop_back</code>，以保证取到的都是在合法区间内的。</li>
</ol>
<h4 id="20235月"><a class="markdownIt-Anchor" href="#20235月"></a> 2023.5月</h4>
<h5 id="202351"><a class="markdownIt-Anchor" href="#202351"></a> 2023.5.1.</h5>
<ol start="29">
<li>洛谷 - P3195 - 玩具装箱 单调栈实现1D1D平行四边形不等式优化DP<br />
需要非常深刻的思考，做了详细的笔记。单调栈实现的方法是一般化方法，比分治法更好，实现上也就是四步，计算新状态值、弹栈、二分、入栈。</li>
<li>洛谷 - P6932 - WF2017D Money for Nothing 分治法实现平行四边形不等式优化DP<br />
DP函数不难写出<code>max&#123;(d[r]-d[l])*(p[r]-p[l]&#125;</code>，首先贪心考虑一个商家的(d,p)值，如果<code>di&lt;dj</code>且<code>pi&lt;pj</code>则商家j一定不如商家i好，所以可以直接将j去掉；买家同理，如果<code>di&gt;dj</code>且<code>pi&gt;pj</code>则买家j一定不如买家i好，直接将j去掉。于是我们得到了买家和卖家的p关于d单调递减的离散函数，根据这个就可以证明<code>w(l,r)=(d[r]-d[l])*(p[r]-p[l])</code>是满足交叉大于包含的平行四边形不等式，所以满足决策单调性，于是用分治法即可解决（应该不能用单调栈解决吧，单调栈解决应该要求决策点和状态值是同一个集合中）</li>
</ol>
<h5 id="202352"><a class="markdownIt-Anchor" href="#202352"></a> 2023.5.2.</h5>
<ol start="31">
<li>UVA - 10859 - Placing Lampposts 树形DP<br />
通过求解技巧在于转换问题，是两个极小化条件，首要条件是灯的数目最少，在灯数目最少前提下，要求每个两段都有灯的边尽可能多（等价于一端有灯的边数最少），可以通过加入大常数M，将这两个问题转化为一个最优化表达式：设灯的数目为a，只有一段有灯的边数为b，且M大于b的上界，则该问题等价于最小化x=Ma+b。这样x/M就是边的数目，x%M就是只有一端有灯的边数。进一步设计状态，f(i,j)表示第i个节点的父节点灯的状态为j的最小x值，通过讨论第i个节点是否放灯进行状态转移，每棵树上进行一次dfs即可（森林中只需每次处理一颗树）</li>
<li>UVA - 1169 - Robotruck - E3 单调队列优化DP<br />
通过转化状态转移方程（将区间求和用前缀和表出，与当前状态值i相关的变量就是常量可以提到min\max外部），再观察决策值集合是关于i严格递增的并且dp的状态值仅和j相关，所以可以使用单调队列优化。</li>
<li>蓝桥杯练习题 - 第二届省赛 - 前四道题</li>
</ol>
<h5 id="202353"><a class="markdownIt-Anchor" href="#202353"></a> 2023.5.3.</h5>
<ol start="34">
<li>蓝桥杯练习题 - 第二届国赛 - 两道题, 第三届省赛 一道题：<br />
查找循环节：有理数a/b，只需记录每个小数点后第i位的值为A[]，并记录计算每个小数点时分子对应值a，与小数点位置的对应关系pos[a]=i（可以用map实现，因为a的最大值是分母的10倍），求小数点后第i位就是 <code>(a*10^(i-1)%b)*10/b</code>，其实只需保留上次小数点分子的值 <code>a</code>，然后 <code>a*10/b</code> 就是当前小数点的值。</li>
<li>UVA - 1099 - Sharing Chocolate 状压DP<br />
利用二进制表示是否选择某个元素的集合（状压），首先想到构建f(x,y,S)表示是否可以通过x行y列的巧克力划分出集合S，然后发现三者必然满足xy=sum(S)，于是又可以将状态减少到两个，y=sum(S)/x，表示为f(x,S)，由于f(x,y,S)=f(y,x,S)，于是又可以每次将行与列中较小者作为状态值x，并且状态转移时只需枚举子集合S0，因为当固定x或y不变时，可通过S0计算出另一个变量例y0=S0/x，最后是枚举子集合的方法：<code>for (int S0 = (S-1)&amp;S; S0; S0 = (S0-1)&amp;S0)</code> 结果与dfs暴力枚举（优先枚举1）效果相同。<br />
注意：记忆化搜索实现dp时，使用 <code>int&amp; ans = f[i][j];</code> 然后最后返回时记录 <code>return ans = 状态值;</code>，并使用 <code>vis[i][j]</code> 记录下该状态是否访问过，如果访问过则直接返回 <code>f[i][j]</code>。</li>
<li>UVA - 11825 - Hackers’ Crackdown 状压DP<br />
本题是很巧妙的问题转换，最大化指标集划分个数，且每个指标集划分中集合之并都是全集，以指标集S作为状态值，转移通过枚举子集S0，并且需要S0指标对应的集合并是全集，则可转移 <code>f(S)=max&#123;f(S-S0)&#125;+1</code>。<br />
注意：本题可以不用记忆化搜索直接<code>for</code>循环完成，因为可以从小到大枚举状态值S，从而保证转移时子状态的dp值一定是存在的。上一题不好使用 <code>for</code>，也正是因为无法保证子状态的dp值在之前是枚举过了的。</li>
<li>UVA - 11995 - I Can Guess the Data Structure! 简单题<br />
判断是否满足栈、队列、优先队列三种数据结构。<br />
注意：实现队列时 <code>queue[front++]</code> 是弹出操作（不是 <code>front--</code>）</li>
<li>UVA - 11991 - Easy Problem from Rujia Liu? 简单题<br />
先用map编号在放入vector数组中，可以直接用 <code>map&lt;int, vector&lt;int&gt; &gt;</code> 代替。</li>
<li>POJ - 2051 - Argus 优先队列简单题<br />
读入结构体中部分元素值时，可以先构建一个结构体实例，然后输入到该实例中。</li>
<li>UVA - 11997 - K Smallest Sums 优先队列合并多个递增序列（多路合并）<br />
核心是利用不等号对加法的保号性（如果问题改成乘法，应该只需合并单减和单增的两个序列），将n维问题转化为两两单增序列的合并，从而从<code>O(k^klogk)</code>降到<code>O(k^2logk)</code>，考虑两个单增序列的合并方法：可以先固定一维，然后移动后一个变量</li>
</ol>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">A<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>B<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> A<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>B<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">&lt;=</span> A<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>B<span class="token punctuation">[</span>n<span class="token punctuation">]</span>
A<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">+</span>B<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> A<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">+</span>B<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">&lt;=</span> A<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">+</span>B<span class="token punctuation">[</span>n<span class="token punctuation">]</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
A<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">+</span>B<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> A<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">+</span>B<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">&lt;=</span> A<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">+</span>B<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>于是变成了n路合并问题，只需要每次将每一路开头的放到优先队列中，然后就可以找到当前最小值，然后取出最小值的后继元素，继续放到优先队列里（优先队列的结构体中可以只存储<code>A[i]+B[j]</code>和<code>j</code>的值），那么合并出来的元素个数也是n个（为什么是n个呢，反证法，如果n+1可以对下一个序列产生贡献，那么一定存在之前n个中的某一个没有被选中，那么它一定小于等于n+1，所以仍然可以从前n个中的元素对后续序列产生贡献，无需n+1元素，矛盾），本质其实用到了不等号对加法的保号性，<code>Ai+Bj&lt;=Ak+Bl</code> 则 <code>Ai+Bj+C&lt;=Ak+Bl+C</code>（所以说如果改成乘法，我认为只需维护前n小和前n大的序列也可完成该问题），总复杂度<code>O(n^2logn)</code>。<br />
41. UVA - 1160 - X-Plosives 并查集判环<br />
在没有重边下环存在的另一种说法：如果把每个端点看作不同的字母，那么环就是存在k个边，并且k个边上的端点对应了k个不同的字母，则一定有环；也就是用n条边将n个节点连接起来，不允许重边，则一定有环（证明很容易想到，因为n个节点用n-1条边连接起来必定是一棵树，一棵树上再加一条边必定出环）</p>
<h5 id="202354"><a class="markdownIt-Anchor" href="#202354"></a> 2023.5.4.</h5>
<ol start="42">
<li>Gym - 101461B - Corporative Network - E1 并查集路径压缩<br />
用并查集可以动态维护每个叶子节点到根节点的距离，只需在路径压缩之前更新距离 <code>int rt=updatefa(u); dis[u]+=dis[fa[u]]; fa[u]=rt;</code></li>
<li>UVA - 1428 - Ping pong 计数问题条件的拆分（用树状数组实现动态前缀和查询）<br />
问题可以转化为求解 <code>C[i] = #&#123;j:A[j]&lt;A[i],1&lt;=j&lt;i&#125;</code>，左侧集合在i处有两个限制条件，由于A[i]和i是已知的，所以限制条件分别为 <code>A[j]&lt;A[i]</code> 和 <code>1&lt;=j&lt;i</code>，暴力枚举复杂度肯定是O(nr)的（r为<code>A[i]</code>的上界），所以我们希望通过固定一个限制条件然后考虑另一个单独条件，从而完成求解，本题有两种做法：</li>
</ol>
<ul>
<li>第一种是固定 <code>1&lt;=j&lt;i</code>，然后求解 <code>#&#123;A[j]&lt;A[i]&#125;</code> 的个数，由于 <code>A[i]</code> 的范围不大只有 <code>1e5</code> 所以这种方法行得通，时间复杂度O(nlogr)</li>
<li>第二种是固定 <code>A[j]&lt;A[i]</code>，然后求解 <code>#&#123;1&lt;=j&lt;i&#125;</code> 的个数，这个方法无需 <code>A[i]</code> 的范围条件，所以时间复杂度O(nlogn)，这种方法更具一般性</li>
</ul>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Bit</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 树状数组模板</span>
    <span class="token keyword">int</span> t<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> t<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">+=</span> i<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> t<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> x<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
    <span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i<span class="token punctuation">;</span> i <span class="token operator">-=</span> i<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> sum <span class="token operator">+=</span> t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">return</span> sum<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span> bit<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<ol start="44">
<li>UVA - 11235 - Frequent values - E3 区间众数（单调递增，可用树状数组实现）<br />
区间众数一般用分块求解，只是本题有数列单增的条件，所以相同的数一定是连在一起的，只需要记录下每段相同数的左端点和右端点，并对每段进行编号，然后将查询的区间分为三部分：<code>[l, min(R[l], r)], [id(l)+1, id(r)-1], [max(L[r], l), r]</code>，分别求出每一段的众数，中间一段可以用rmq倍增求解。<br />
注意：对区间进行编号时，直接对区间id进行+1或-1的操作，而不是先转移下标然后找id，也就是<code>id(l)+1</code>不一定和<code>id(R(l)+1)</code>一样，因为如果l是最右侧的一段区域，那么<code>R(l)+1</code>就没有对应区间id了。</li>
</ol>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">RMQ</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 2023.5.25.重写了一遍RMQ模板</span>
    <span class="token keyword">int</span> log2<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> f<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 1&lt;&lt;16 &lt;= maxn &amp;&amp; 1&lt;&lt;17 > maxn</span>
    <span class="token function">RMQ</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> log2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> log2<span class="token punctuation">[</span>i<span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>j<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>j<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
                f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">></span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> k <span class="token operator">=</span> log2<span class="token punctuation">[</span>r<span class="token operator">-</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>r<span class="token operator">-</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>k<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<ol start="45">
<li>UVA - 1400 - “Ray, Pass me the dishes!” - E10! 动态区间查询最大连续和<br />
最大连续和如果是静态的（就是在[1,n]上求），可以直接O(n)的dp完成，用 <code>f[i]</code> 表示以 <code>A[i]</code> 结尾的最大连续和，则 <code>f[i] = max&#123;A[i], A[i]+f[i-1]&#125;</code> 。也可以用 O(nlogn) 的分治法完成，只需记录左右区间的最大前缀和和最大后缀和，线段树上合并的方法就类似分治法，记录每个子区间的最大前缀和和最大后缀和，然后就可以合并得到最大连续和。<br />
技巧：
<ul>
<li>将区间的值val和左右端点用一个结构体记录，然后两个区间的比较可以根据题意，首先比较两个区间的值，然后比较左端点，最后比较右端点，注意只需重载小于号。</li>
<li>结构体套结构体的初始化可以用 <code>&#123;&#125;</code> 生成写法，例如 <code>struct Node&#123;Segment a, b; int l, r;&#125;; struct Segment&#123;int l, r;&#125;</code> 于是可以直接生成<code>Node&#123; &#123;l1,r1&#125;, &#123;l2,r2&#125;, l,r&#125;</code> 一个 <code>Node</code> 元素。<br />
注意：计算左孩子时候的位运算是 <code>ls=(p&lt;&lt;1)</code>，不要写反了！</li>
</ul>
</li>
<li>蓝桥杯 - 第三届省赛 - 取球游戏 NIM游戏<br />
由于数据量只有 <code>1e4</code>，所以直接线性递推输赢就行，<code>f[i]</code> 表示先手拿到 <code>i</code> 个球是否必胜，<code>f[i] = max&#123;f(i-k)^1:k=&#123;1,3,7,8&#125;, k&lt;=i&#125;</code>，边界 <code>f[0]=1</code>。</li>
</ol>
<h5 id="202355"><a class="markdownIt-Anchor" href="#202355"></a> 2023.5.5.</h5>
<ol start="47">
<li>UVA - 11992 - Fast Matrix Operations 线段树区间修改区间多目标查询<br />
由于该题存在多个线段树，所以我使用的是指针实现的线段树，无需考虑每个线段树的具体大小，但速度会满一些（没有特意卡常应该不会超时）；该题主要是需要查询三个目标包含 <code>sum, mx, mn</code>（区间和、最大值、最小值），可以设计结构体 <code>Segment</code> 存储每个节点的这三个信息，由于维护区间和还需要区间长度，所以还需记录 <code>len</code>，再设计修改函数 <code>set(x), add(x)</code>；再对线段树中每个节点设计 <code>Node</code> 结构体，该结构体中存储 <code>Node *ls, *rs; int l, r, addv, setv; Segment seg;</code> 分别表示该节点的左右儿子，左右区间端点，add操作的懒标记和set的懒标记，seg表示该节点的信息。只需注意以下几点：
<ul>
<li>Segment 的初始化问题，如果对答案进行合并，那么mx初始化为最小值，mx初始化为最大值。</li>
<li>线段树中合并，在update函数结束时父节点更新子节点的区段信息 <code>p-&gt;seg = ls-&gt;seg + rs-&gt;seg</code>，在build时候直接传输 <code>Node*</code> 地址。</li>
<li>懒标记下传，在update，query中每次进入子节点时候都要进行懒标记下传。标记下传一般分为两步，首先是树节点的 <code>addv, setv</code> 的更新，然后是区段信息 <code>seg</code> 的更新。<br />
注：其实 <code>setv</code> 无需存储，因为set之后一定是叶子节点，并回收内存。</li>
</ul>
</li>
<li>校赛测试4题</li>
</ol>
<h5 id="202356"><a class="markdownIt-Anchor" href="#202356"></a> 2023.5.6.</h5>
<ol start="47">
<li>SPOJ - NKMOU - IOI05 Mountains 动态开点线段树+二分查询<br />
需要用线段树维护前缀最大和，所以需要区间求和 <code>sum</code> 和区间前缀最大和 <code>mxpre</code>，问题查询就是线段树上二分答案，本题主要是数据范围为1e9所以不能用传统数组线段树，只能用动态开点线段树，时间复杂度只与操作数有关 <code>nlogn</code>。<code>set</code> 操作无需懒标记，因为set之后整个区间段都是一个值，所以回收内存。动态开点需要注意指针的使用，建议在传输节点时使用 <code>&amp;</code> 而不是指针，因为 <code>&amp;</code> 可以用 <code>.</code> 来引用内部变量，而指针需要用 <code>-&gt;</code> 比较麻烦，bug不容易看出来。</li>
</ol>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Segment</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 记录区间信息，要维护的值例如区间长度len，区间和sum，区间最大最小值mx,mn，区间最大前缀和mxpre</span>
    LL len<span class="token punctuation">,</span> sum<span class="token punctuation">,</span> mxpre<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> sum <span class="token operator">=</span> len <span class="token operator">*</span> x<span class="token punctuation">;</span> mxpre <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0LL</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// 与题目给出的区间操作对应，例如区间赋值set，区间增加某个值add</span>
    Segment <span class="token keyword">operator</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Segment <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 区间合并，用于合并两个子区间的信息</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>Segment<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>len <span class="token operator">+</span> rhs<span class="token punctuation">.</span>len<span class="token punctuation">,</span> sum <span class="token operator">+</span> rhs<span class="token punctuation">.</span>sum<span class="token punctuation">,</span> <span class="token function">max</span><span class="token punctuation">(</span>mxpre<span class="token punctuation">,</span> sum <span class="token operator">+</span> rhs<span class="token punctuation">.</span>mxpre<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span>
    Node <span class="token operator">*</span>ls<span class="token punctuation">,</span> <span class="token operator">*</span>rs<span class="token punctuation">;</span>  <span class="token comment">// 1. 左右儿子指针</span>
    <span class="token keyword">int</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> val<span class="token punctuation">;</span>  <span class="token comment">// 区间的左右端点[l,r]，2. 区间的值val（全部为统一值（叶子节点）时才有作用）</span>
    Segment seg<span class="token punctuation">;</span>  <span class="token comment">// 区间段信息</span>
    <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">l</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">r</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">val</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> ls <span class="token operator">=</span> rs <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> seg<span class="token punctuation">.</span>len <span class="token operator">=</span> r<span class="token operator">-</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> seg<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// 3. 初始化树节点，初始化只需区间的左右端点和初值，因为初始化的一定是叶子节点，所以是统一初值的</span>
    <span class="token keyword">bool</span> <span class="token function">isleaf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token operator">!</span>ls <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>rs<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// 4. 判断是否是叶子节点，其实只需判断ls和rs其中一个</span>
    <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> val <span class="token operator">=</span> x<span class="token punctuation">;</span> seg<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">del</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// 与题目给出的区间操作对应，如果有懒标记记得更新懒标记(addv)，5. 如果是重置set，则可以回收内存</span>
    <span class="token keyword">void</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 6. 创建左右儿子节点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isleaf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>
        ls <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        rs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">void</span> <span class="token function">del</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ls<span class="token punctuation">)</span> <span class="token keyword">delete</span> ls<span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rs<span class="token punctuation">)</span> <span class="token keyword">delete</span> rs<span class="token punctuation">;</span> ls <span class="token operator">=</span> rs <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// 内存回收</span>
    <span class="token operator">~</span><span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">del</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// 7, 析构函数，在delete rt时会递归调用del，所以可以递归删除整棵树</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
Node <span class="token operator">*</span>rt <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>  <span class="token comment">// 树根节点</span>
<span class="token keyword">void</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rt<span class="token punctuation">)</span> <span class="token keyword">delete</span> rt<span class="token punctuation">;</span> rt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// 8. 如果旧树存在则先删除，然后只需构建出新的树根节点</span>
<span class="token keyword">void</span> <span class="token function">pushdown</span><span class="token punctuation">(</span>Node <span class="token operator">&amp;</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> p<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// 下传懒标记，首先要创建左右儿子节点（如果没有），因为这只在update和query中使用到，并且只会在update处进行新节点创建，query只会下传懒标记</span>
<span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> Node <span class="token operator">&amp;</span>p <span class="token operator">=</span> <span class="token operator">*</span>rt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 这里的更新操作就是区间重置</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> p<span class="token punctuation">.</span>l <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>r <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> p<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
    <span class="token function">pushdown</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>l <span class="token operator">+</span> p<span class="token punctuation">.</span>r<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 一定要根据mid进行递归方向判断，直接进入然后遇错返回会慢很多</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token function">update</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> x<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">.</span>ls<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">></span> mid<span class="token punctuation">)</span> <span class="token function">update</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> x<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">.</span>ls<span class="token punctuation">)</span><span class="token punctuation">;</span>
    p<span class="token punctuation">.</span>seg <span class="token operator">=</span> p<span class="token punctuation">.</span>ls<span class="token operator">-></span>seg <span class="token operator">+</span> p<span class="token punctuation">.</span>rs<span class="token operator">-></span>seg<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> Node <span class="token operator">&amp;</span>p <span class="token operator">=</span> <span class="token operator">*</span>rt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 这是单点查找满足最大前缀和不超过h的节点的例子</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>seg<span class="token punctuation">.</span>mxpre <span class="token operator">&lt;=</span> h<span class="token punctuation">)</span> <span class="token keyword">return</span> p<span class="token punctuation">.</span>r<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">isleaf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> p<span class="token punctuation">.</span>l <span class="token operator">+</span> h <span class="token operator">/</span> p<span class="token punctuation">.</span>val <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 10. 这里一定要判断是否是叶子节点，因为叶子节点已经是全部相同的val，可以得到要求的区间信息</span>
    <span class="token comment">// pushdown();  // 如果有懒标记则这里也需要pushdown</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">>=</span> p<span class="token punctuation">.</span>ls<span class="token operator">-></span>seg<span class="token punctuation">.</span>mxpre<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">query</span><span class="token punctuation">(</span>h<span class="token operator">-</span>p<span class="token punctuation">.</span>ls<span class="token operator">-></span>seg<span class="token punctuation">.</span>sum<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">.</span>rs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">query</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">.</span>ls<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> Node <span class="token operator">&amp;</span>p <span class="token operator">=</span> <span class="token operator">*</span>rt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 这是求区间和的例子</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>l <span class="token operator">==</span> l <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>r <span class="token operator">==</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> p<span class="token punctuation">.</span>seg<span class="token punctuation">.</span>sum<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">isleaf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> p<span class="token punctuation">.</span>val <span class="token operator">*</span> <span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 10. 一定要判断是否叶子节点，并返回</span>
    <span class="token comment">// pushdown();</span>
    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>l<span class="token operator">+</span>p<span class="token punctuation">.</span>r<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">query</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> p<span class="token punctuation">.</span>ls<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">></span> mid<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">query</span><span class="token punctuation">(</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> p<span class="token punctuation">.</span>rs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token function">query</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> p<span class="token punctuation">.</span>ls<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">query</span><span class="token punctuation">(</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> p<span class="token punctuation">.</span>rs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>总的来说就是上述的10点和传统线段树不同的位置。</p>
<ol start="48">
<li>UVA - 12419 - Heap Manager 线段树动态开点+二分查询<br />
如果用1表示区间被占用，0表示区间空闲，则每个区间 <code>[l,r]</code> 只需维护 <code>pre, sub, suf</code> 前缀最大连续0、字串最大连续0、后缀最大连续0的长度。还是和上面的方法一致：</li>
</ol>
<ul>
<li>结构体 <code>Info</code> 维护区间信息，包含 <code>len, pre, sub, suf</code> 参数和重载 <code>+</code> 用于区间信息合并，本题有重置操作，所以还要 <code>set(x)</code> 函数。</li>
<li>结构体 <code>TNode</code> 维护树上节点信息，包含 <code>TNode *ls, *rs; int l, r, val; Info info;</code> 含义与上题一致。需要 <code>Node(l,r,val), isleaf(), set(x), create(), del(), ~Node()</code> 六个函数。</li>
<li>结构体 <code>SEG</code> 线段树，包含 <code>Node *rt</code> 为当前的树根节点。其他函数为 <code>build(n), pushdown(p), pushup(p), update(p,l,r,val), query(p,l,r,len)</code>，最后还可以加一个 <code>check(len)</code> 函数用于检查当前内存能否放入 <code>len</code> 长度的进程，即判断 <code>len &lt;= rt-&gt;info.sub</code>。<br />
注意：线段树中 <code>update,query</code> 区间操作时，一定要根据当前节点的 <code>mid</code> 位置来指定下一个子节点的移动方向，而不是先进入再遇错返回，这样会浪费很多时间。（本题慢了一倍）</li>
</ul>
<h5 id="202357"><a class="markdownIt-Anchor" href="#202357"></a> 2023.5.7.</h5>
<p>2023年XJTU校赛<br />
场上和wyz一起做出了11道题，拿了校一不错的成绩，下面对剩余4题进行补充：<a target="_blank" rel="noopener" href="https://maifile.cn/est/d2636833627652/pdf">题面</a></p>
<ol start="49">
<li>XJTUOJ - #1384 - 2023XJTUPC G.和而不同 - 构造题<br />
条件非常构造的一道题，构造图的题往往可以从最简单的开始想，本题只要构造出链就完成了，并且链的权重就是从最大的权重向下取整开始(n+1)^2/4，然后后续每个权重依次减一就好了。证明上首先注意到如果长度m相同的两个最短路，它们的长度一定不同，所以只需考虑两个长度相邻的最短路m和m+1，如果这两个长度上不交，则说明任意两个长度的最短路长度都没有交。（只是这个确实太特殊了，用的其实就是归纳法证明）<br />
长度为m+1的最小边权和为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mn>1</mn><mo>=</mo><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mi>n</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mi>n</mi><mo>+</mo><mn>2</mn><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mi>k</mi><mo>−</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>4</mn><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">s1=(k-n+2)+...+(k-n+2+m)=(2k-2n+4+m)(m+1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>，长度为m的最小边权和为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mn>2</mn><mo>=</mo><mi>k</mi><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mi>k</mi><mo>−</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mi>k</mi><mo>−</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">s2=k+...+k-m+1=(2k-m+1)m/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathnormal">m</span><span class="mord">/</span><span class="mord">2</span></span></span></span>，将二者做差<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mn>1</mn><mo>−</mo><mi>s</mi><mn>2</mn><mo>=</mo><msup><mi>m</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>m</mi><mo>−</mo><mi>n</mi><mi>m</mi><mo>−</mo><mi>n</mi><mo>+</mo><mn>2</mn><mo>+</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">s1-s2=m^2+2m-nm-n+2+k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，再将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">k=(n+1)^2/4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">4</span></span></span></span>带入，该函数视为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>为变量，就会发现<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>最小值大于0，所以两最短路一定两两无交。</li>
<li>XJTUOJ - #1392 - 2023XJTUPC O.打则 - 数学题<br />
更离谱的一道题，答案就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mclose">!</span></span></span></span>，只是要同构证明推导。（还在想）</li>
</ol>
<ul>
<li>J. 大秦酒店欢迎您 - 线段树或莫队（卡常）</li>
<li>I. 喵喵喵 - 数学题</li>
</ul>
<h5 id="202358"><a class="markdownIt-Anchor" href="#202358"></a> 2023.5.8.</h5>
<ol start="51">
<li>XJTUOJ - #1388 2023XJTUPC K.莉可丽丝 - DAG最短路<br />
该题是全场最后一个提交通过的，体现出太菜了，当时太紧张做的很丑陋，于是重写了一遍。主要思路就是：由于要求两条路径边的并的权重最小值，通过思考最终状态（逆向思考），我们一定可以发现，两条最短路的并结果一定是，从1节点开始前面一段一样的路径（可能长度为0），中间分开走两条不同的路径，最后合并回一条路径上（可能长度为0），所以我们只要枚举中间分开的节点u和v，只需要预处理出每个节点开始的单源最+次短路即可（次短路只需要记录每个节点的前两短的路径，然后就可以更新了），由于是DAG图，所以可以O(n)求出单源最短路。最后枚举所有的u,v答案就是<code>ans=min&#123;dis[1][u].d1+dis[u][v].d1+dis[u][v].d2+dis[v][n].d1&#125;</code>其中<code>d1</code>表示最短路，<code>d2</code>表示次短路。<br />
技巧：
<ul>
<li>可以用结构体存储路径长度信息（最短路和次短路），这样更新路径的函数就可以写进结构体中，代码更容易书写。</li>
<li>拓朴排序只需要记录下每个节点的拓扑序，其实就是进队的次序，然后每次距离初始化为0的点不同，使用进队次序再次求最短路，就可以得到不同点开始的最短路径了。</li>
</ul>
</li>
</ol>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> in<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> q<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> rear<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">toposort</span><span class="token punctuation">(</span><span class="token keyword">int</span> st<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    q<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> st<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> front <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> front <span class="token operator">&lt;=</span> rear<span class="token punctuation">;</span> front<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 每次都是取出队首元素可以这样写</span>
        <span class="token keyword">int</span> u <span class="token operator">=</span> q<span class="token punctuation">[</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> e <span class="token operator">=</span> head<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span> e<span class="token punctuation">;</span> e <span class="token operator">=</span> E<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">.</span>nt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> v <span class="token operator">=</span> E<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">.</span>b<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>in<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<figure><div class="code-wrapper"><pre class="language-none"><code class="language-none">注意：如果结构体中变量有初值，则不能用`(Dis)&#123;&#125;`（列表初始化了），这里建议使用构造函数`Dis(int d1=INF, int d2=INF):d1(d1),d2(d2) &#123;&#125;`。
</code></pre></div></figure>
<h5 id="202359"><a class="markdownIt-Anchor" href="#202359"></a> 2023.5.9.</h5>
<ol start="52">
<li>洛谷 - P6242 【模板】线段树 3 - 区间历史最值&amp;区间上界限制<br />
在线段树中进行了详细的总结，主要是区间上界限制的复杂度证明。</li>
<li>洛谷 - U216697 线段树区间历史版本和 - 区间历史和<br />
每个节点需要将当前和 <code>sum</code> 和历史和 <code>sum_</code> 区分开，并且同时维护这两个信息，其实可以容易想到 <code>sum</code> 的所有相关标记 <code>sum_</code> 一定至少要有，并且还要知道在标记下传前一共历史操作作用了多少次 <code>tv</code>。<br />
详细地说：使用区间懒标记 <code>tv</code> 来记录懒标记下传前有多少个区间和没有更新到历史和中，由于本题还有对区间加法操作，所以需要区间加法的懒标记 <code>addv</code>，对于历史区间同样需要对应的懒标记 <code>addv_</code>，因为要记录该懒标记有多少次没有更新到下面的区间中，这种多标记更新的方法写一个更新函数更加方便 <code>update(k, k_, t)</code> 表示区间加法修改量和历史加法修改量，最后的 <code>t</code> 表示区间懒标记，也就是有多少个当前节点的 <code>sum</code> 和 <code>addv</code> 还没更新到历史中去，最关键的就历史更新是要优先在当前更新之前的：</li>
</ol>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>LL k<span class="token punctuation">,</span> LL k_<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// Info区间信息更新</span>
    sum_ <span class="token operator">+=</span> k_ <span class="token operator">*</span> len <span class="token operator">+</span> sum <span class="token operator">*</span> t<span class="token punctuation">;</span>  <span class="token comment">// 历史更新优先于当前区间更新</span>
    sum <span class="token operator">+=</span> k <span class="token operator">*</span> len<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>LL k<span class="token punctuation">,</span> LL k_<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// TNode树上节点更新</span>
    info<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> k_<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    tv <span class="token operator">+=</span> t<span class="token punctuation">;</span>
    addv_ <span class="token operator">+=</span> addv <span class="token operator">*</span> t <span class="token operator">+</span> k_<span class="token punctuation">;</span>  <span class="token comment">// 历史懒标记更新优先于当前懒标记更新</span>
    addv <span class="token operator">+=</span> k<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<figure><div class="code-wrapper"><pre class="language-none"><code class="language-none">最后一个重点就是标记下传，分别对历史区间和当前区间的懒标记分别进行下传并更新就好了 `t[ls].update(addv, addv_, t)`。
</code></pre></div></figure>
<h5 id="2023510"><a class="markdownIt-Anchor" href="#2023510"></a> 2023.5.10.</h5>
<ol start="54">
<li>
<p>XJTUOJ - #1387 2023XJTUPC J.大秦酒店欢迎您 - 线段树历史区间和<br />
非常巧妙的转换，首先由 [SDOI2009] HH的项链 可知，区间颜色数可以对询问进行离线，然后对右端点进行排序，假设当前数组中的第<code>i</code>个位置的元素<code>a[i]</code>表示从<code>i</code>到当前枚举到的右端点<code>r</code>即<code>[i...R]</code>中的颜色种类数，考虑每次右端点的颜色对哪些区间的颜色数有贡献，不难发现，如果最右侧加入新的颜色为<code>color[R]</code>，那么如果<code>1...R-1</code>中最右侧出现的<code>color[R]</code>位置在<code>p</code>，那么这种颜色就会对<code>p...R</code>的所有位置的颜色数<code>+1</code>的贡献。又可以发现，<code>a[i]</code>在<code>[l,r]</code>的区间和就是<code>[i,R]:l&lt;=i&lt;=r</code>中每个区间的颜色种类数之和，对于右端点在<code>R</code>的时刻，我们统计<code>[l,R]</code>上的<code>a[i]</code>相当于得到了所有右端点为<code>R</code>的颜色种类数，所以如果把历史中每次更新<code>R</code>的区间和全部加起来，那就是区间<code>[l,R]</code>上所有子区间的颜色种类数。</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>a</mi><mi>i</mi><mi>R</mi></msubsup></mrow><annotation encoding="application/x-tex">a_i^R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0999949999999998em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span> 为<code>[i,R]</code>的所有颜色种类数。</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>l</mi></mrow><mi>R</mi></msubsup><msubsup><mi>a</mi><mi>i</mi><mi>R</mi></msubsup></mrow><annotation encoding="application/x-tex">\sum_{i=l}^Ra_i^R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2809409999999999em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span> 为<code>[l,R]</code>的所有右端点为<code>R</code>每个区间的颜色种类数之和（<code>a[i]</code>的区间和）</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mi>l</mi></mrow><mi>R</mi></msubsup><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>l</mi></mrow><mi>j</mi></msubsup><msubsup><mi>a</mi><mi>i</mi><mi>j</mi></msubsup></mrow><annotation encoding="application/x-tex">\sum_{j=l}^R\sum_{i=l}^ja_i^j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.417049em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.964564em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span style="top:-3.2029000000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.942572em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span></span></span></span> 为<code>[l,R]</code>中所有子区间的颜色种类数之和（<code>a[i]</code>的历史区间和，因为右端点<code>R</code>是从左到右逐个枚举过去的，历史和就是第一个求和符号）<br />
所以本题就变成了带有区间加法的区间历史和，与洛谷 - U216697完全一致。</li>
</ul>
</li>
<li>
<p>UVA - 11136 - Hoax or what - 集合最大值与最小值<br />
使用multiset即可动态维护集合的最大值与最小值。</p>
</li>
<li>
<p>UVA - 12232 - Exclusive-OR - E18!!! - 异或操作转边权和<br />
18次错误提交，心态差点蹦了，结果发现是pdf上的<code>I don’t know.</code>中的引号字体不对，竟然是中文引号，在手机上pdf也是这个，pdf上应该没有字体问题，而正确的应该是英文引号<code>I don't know.</code>（离谱）<br />
本题主要就是利用异或的可加性，把每个值看作一个节点，每个二元异或操作<code>p q v</code>就是用边权为<code>w</code>的边连接<code>p q</code>节点，不难发现一个性质，如果两个节点<code>u v</code>连接在同一个根节点<code>rt</code>下，那么<code>a[u]^a[v]</code>也就是<code>dis[u]^dis[v]</code>，因为可以看作<code>a[u]^a[rt]^a[rt]^a[v]</code>，由于异或的性质中间的<code>a[rt]</code>消去，所以两个点的异或询问就是树上两点路径的<strong>异或和</strong>。总的来说每种操作具体实现如下：</p>
<ol>
<li>操作1，给出<code>p</code>的值<code>v</code>，如果一个集合中的某一个点已知，那么所有点的值均已知；（所有已知的点可以连接到超级根节点上，这样他们到超级根节点的距离的异或和就是对应的值）</li>
<li>操作2，给出两个点<code>p q</code>的异或值<code>v</code>，可以分别找到对应的根节点<code>rt1 rt2</code>，用边权为<code>v^a[p]^a[q]</code>的边连接起来就好了；（使用这个边权还是用的异或相消的性质，注意根节点的连接处的细节，如果一个根节点的值已知，也就是他是超级根节点，那么另一个根节点就连接到其子节点上）</li>
<li>操作3，询问<code>a[p1]^a[p2]^...^a[pk]</code>，首先把所有已知值的点全部异或起来，然后剩下的可以发现，由于只能通过两两之间的异或值得到，所以只需考虑所有节点所在集合的根节点的数目，如果是偶数个，则一定可以两两配对；否则一定无法消去根节点的值，输出<code>I don't know.</code>。<br />
技巧：本题能大幅度减少代码量的技巧就是设计<strong>超级根节点</strong>（节点编号为<code>0,...,n-1</code>那么超级根节点可以设计为<code>n</code>），将所有已知值的节点全部连接到超级根节点上，这样如果<code>getfa()</code>得到的根节点是<code>n</code>，则说明该点的值已知。并且可以将操作1和操作2合并，操作1相当于合并了<code>p n v</code>三个点。<br />
其余要注意的细节也很多：</li>
</ol>
<ul>
<li><code>^</code> 异或符号的优先级是低于 <code>!=</code> 和 <code>==</code> 的（多数位运算操作都是），所以判断条件时候要<strong>把位运算括起来</strong>。</li>
<li>并查集使用的时候，一定要注意在带有路径信息的集合合并时，注意是哪个根节点与另一个根节点进行合并。（例如本题中两个根节点，如果有一个根节点值已知，那么另一个根节点就作为他的子节点）</li>
<li>读入一行的方法有很多，首先是自定义读入函数 <code>read()</code>，其次是在假定一行的总长度的前提下可以用 <code>fgets</code> 读入到字符串，然后用 <code>sscanf</code> 读取：</li>
</ul>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span> opt<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">fgets</span><span class="token punctuation">(</span>opt<span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 假定一行的最大输入字符数为31（注意包括了终止符0，所以读入30个字符）</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sscanf</span><span class="token punctuation">(</span>opt<span class="token punctuation">,</span> <span class="token string">"%d%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">,</span> <span class="token operator">&amp;</span>q<span class="token punctuation">,</span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> v <span class="token operator">=</span> q<span class="token punctuation">,</span> q <span class="token operator">=</span> n<span class="token punctuation">;</span>  <span class="token comment">// 判断读入是2个还是3个</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure>
<p>这个方法是蛮好用的，只需计算出读入的字符数量上界，如果是<code>int</code>整数最多<code>11</code>个字符，加上空格分隔就是<code>12</code>个字符，读入<code>n</code>个也就是最多<code>12n+1</code>个字符大小就够了。</p>
<p>最后一种是最慢的 <code>getline(cin, str)</code>，使用<code>stringstream</code>重载输入流：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream></span>  <span class="token comment">// 两个头文件</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
string str<span class="token punctuation">;</span> <span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 读入一行</span>
stringstream <span class="token function">ss</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 重载输入流</span>
ss <span class="token operator">>></span> a <span class="token operator">>></span> b<span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>ss <span class="token operator">>></span> c<span class="token punctuation">)</span><span class="token punctuation">)</span> c <span class="token operator">=</span> b<span class="token punctuation">,</span> b <span class="token operator">=</span> n<span class="token punctuation">;</span>  <span class="token comment">// 判断读入是2个还是3个</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
</li>
</ol>
<h5 id="2023511"><a class="markdownIt-Anchor" href="#2023511"></a> 2023.5.11.</h5>
<ol start="57">
<li>UVA - 11987 - Almost Union-Find - E1 - 并查集合并和单点转移<br />
主要就是如何将集合中的单点进行转移到另一个集合中，想到每次单点转移不要转移真实的本体，而是创建一个新的节点代替原来的，将原来的节点永远抛弃掉。所以总共可能产生的节点数就是n+m个，并每次将整个集合的信息保存在根节点上就好了。</li>
<li>UVA - 12299 - RMQ with Shifts - 线段树单点修改模板题<br />
只需注意读入上的问题就好了，由于每个询问长度不超过30个字符，所以交换的个数也不超过30个，直接暴力单点修改，区间最小值查询即可。</li>
</ol>
<h5 id="2023513"><a class="markdownIt-Anchor" href="#2023513"></a> 2023.5.13.</h5>
<ol start="59">
<li>UVA - 1232 - SKYLINE - 动态开点线段树，暴力修改<br />
注意到本题的结果不超过<code>2e6</code>，所以对于每次查询，暴力找该区间上以当前值为最大值的子区间，然后对其进行修改并统计答案，这样修改的最坏时间复杂度是每个点都是单点修改，那么也不会超过<code>O(2e6*logn)</code>，所以可以直接求解。区间信息只需记录最小值和最大值，由于默认初始全部为0，所以可以使用动态开点线段树。</li>
<li>UVA - 11525 - Permutation - 线段树二分查询<br />
注意题目的问法，该问题就是从序列<code>1,...,n</code>中每次选出第<code>si+1</code>大的元素，然后从中删去。这就可以用线段树十分简单的实现，每个区间记录可用点的数目，然后二分结果删去即可。</li>
</ol>
<h5 id="2023514"><a class="markdownIt-Anchor" href="#2023514"></a> 2023.5.14.</h5>
<ol start="61">
<li>UVA - 1455 - Kingdom - 线段树区间修改+单点查询+并查集<br />
关键就是要把一整个州看作一个整体加入到线段树中，而不是把边的信息加入到线段树中，这样就变成线段树的区间修改+单点查询了。</li>
</ol>
<h5 id="2023515"><a class="markdownIt-Anchor" href="#2023515"></a> 2023.5.15.</h5>
<ol start="62">
<li>UVA - 1401 - Remember the Word - E3 - Trie+DP组合<br />
一类分解方案书的问题都可以考虑用DP组合求解诶：考虑与目标相关的方案数，设计状态转移方程并优化复杂度。对于本题有两个DP方程：<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mo>∑</mo><mo stretchy="false">{</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>:</mo><mi>x</mi><mtext> </mtext><mi>i</mi><mi>s</mi><mtext> </mtext><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>N</mi><mo stretchy="false">]</mo><mtext> </mtext><mi>p</mi><mi>r</mi><mi>e</mi><mi>f</mi><mi>i</mi><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">}</mo><mspace linebreak="newline"></mspace><mi>g</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mo>∑</mo><mo stretchy="false">{</mo><mi>g</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>:</mo><mi>x</mi><mtext> </mtext><mi>i</mi><mi>s</mi><mtext> </mtext><mi>s</mi><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">]</mo><mtext> </mtext><mi>s</mi><mi>u</mi><mi>f</mi><mi>f</mi><mi>i</mi><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">f(i)=\sum\{f(i+len(x):x\ is\ s[i,\cdots,N]\ prefix]\}\\
g(i)=\sum\{g(i-len(x):x\ is\ s[1,\cdots,i]\ suffix]\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mspace"> </span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mspace"> </span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">]</span><span class="mspace"> </span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mclose">}</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mspace"> </span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mspace"> </span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace"> </span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mclose">}</span></span></span></span></span></p>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>N</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[i,\cdots,N]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">]</span></span></span></span>的分解个数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>N</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[1,\cdots,N]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">]</span></span></span></span>的分解个数，由于Trie树可以在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span><strong>查找前缀</strong>串，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>为Trie的最大深度，所以转移方程最好与前缀枚举有关，不难发现<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>是最优选择。总时间为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(NM)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span>.<br />
注意：数组的数据类型，有字符串和int要区别开！！</li>
<li>UVA - 11732 - “strcmp()” Anyone? - E2 - Trie<br />
Trie往往和树上组合相关，一定要从一个局部结构入手，定义清楚每次计算的目标，该问题中s(i)表示s串的第i位，假设s(i-1)对应Trie树p节点，s(i)对应Trie树q节点，那么我们考虑所有之前加入过Trie树的p节点对应前缀出现次数为val[p]，则当前q节点对答案产生的贡献为<code>val[q]*2+val[p]-val[q]=val[p]+val[q]</code>，这部分贡献包含两个，第一个是和s(1…q)相同的前缀数并乘二<code>val[q]*2</code>，第二个是在第s(i)位与其不同的前缀数<code>val[p]-val[q]</code>，不同的字符只会被比较一次。</li>
<li>UVA - 1328 - Period - KMP求解字符串的最小周期长度<br />
KMP具有求解字符串最小周期长度的作用，首先给出结论：**当<code>(i-fail[i])|i</code>时（<code>a|b</code>表示a整除b），<code>i-fail[i]</code>为它的最小周期长度。**通过证明下面两个引理即可证明：
<ol>
<li>在<code>s[0,...,i-1]</code>具有周期性（可以将其划分为几个相同的串的拼接）的前提下，<code>i-fail[i]</code>就是这些周期长度中最小的一个。</li>
<li>反之，由<code>fail</code>数组的性质，如果<code>(i-fail[i])|i</code>，则<code>i-fail[i]</code>一定是一个周期长度。<br />
两个引理都可以用画图理解+归纳法来证明，主要要看到以<code>i</code>结尾长度为<code>i-fail[i]</code>后缀对应的子串会和之前<code>fail[i]-1</code>结尾的字串对应相同长度的后缀相同，利用已有的周期串相同，将该子串位置进行交换，从而得到子串拼接，进一步得到周期串。</li>
</ol>
</li>
<li>UVA - 1449 - Dominating Patterns - E5 - AC自动机模板题<br />
模板题，主要可以学习一种向失配节点传递信息可以用逆向拓扑序完成（和SAM桶排序有点类似）。<br />
注意：字符串的题数组会开非常多，每个数组的<strong>数组大小</strong>一定要注意是否书写正确。还有一定要对每个数组都<strong>检查一遍初始化</strong>。</li>
</ol>
<h5 id="2023516"><a class="markdownIt-Anchor" href="#2023516"></a> 2023.5.16.</h5>
<ol start="66">
<li>UVA - 11468 - Substring - E1 - AC自动机+概率DP<br />
给出生成串中每个字符的概率大小，在AC自动机上不包含任何串的生成串的概率。设计状态<code>f[i][j]</code>表示在节点<code>i</code>再走<code>j</code>步不包含任何模式串的概率，于是可以由全概率公式（每个条件概率对每个条件发生的概率加权平均）得到转移方程<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><msub><mi>c</mi><mi>k</mi></msub><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>⋅</mo><msub><mi>p</mi><msub><mi>c</mi><mi>k</mi></msub></msub><mo>⋅</mo><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><msub><mi>c</mi><mi>k</mi></msub><mtext>不包含任何模式串</mtext><msub><mo stretchy="false">]</mo><mrow></mrow></msub></mrow><annotation encoding="application/x-tex">f(i,j) = \sum_{k=1}^nf(i+c_k,j-1)\cdot p_{c_k}\cdot [i+c_k\text{不包含任何模式串}]_{}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.9535100000000005em;vertical-align:-1.302113em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.70031em;vertical-align:-0.25586em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139199999999997em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25586em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord text"><span class="mord cjk_fallback">不包含任何模式串</span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-1.85em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>+</mo><msub><mi>c</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">i+c_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 后面添加上字符 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">c_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 走到的节点。<br />
并且由于我们只需要判断一个节点是否包含模式串，所以可以将<code>val[],last[]</code>合并为一个数组<code>match[]</code>，表示当前节点为后缀中是否包含模式串，只需要在<code>insert</code>函数中将模式串终止节点设置为<code>match[p]=1</code>，<code>match[v] |= match[fail[v]]</code>即可判断后缀中所有可能的模式串。<br />
注意：这种运用结构体中函数较多的问题，一定要先把主程序写好，否则主程序写一半去写结构体，主程序就容易漏东西，例如这体就开始忘了<code>ac.getfail()</code>样例太小看不出来错误。</li>
<li>UVA - 11019 - Matrix Matcher - E1 - AC自动机二维匹配（或者Hash也可做，还没尝试）<br />
将二维的模式串按行加入到AC自动机中，然后再对文本串也按行进行匹配，用<code>cnt[r][c]</code>表示<code>(r,c)</code>作为模式串左上角已匹配到的行数，假设当前文本串为第<code>r</code>行，如果<code>r</code>在<code>c</code>处完全匹配到模式串中的第<code>v</code>行，则<code>cnt[r-v][c-y+1]++</code>，其中<code>y</code>为模式串的列数，需要注意判断<code>r-v&gt;=0</code>这个条件，不然可能数组溢出。</li>
<li>LibreOJ - 111 - 后缀排序 - 后缀数组模板题<br />
学习了后缀数组SA的基数排序构造方法，非常巧妙，基于倍增的排序原理，加上基数排序可以在O(nlogn)求出后缀数组，只需要4倍空间大小，比SAM小很多。</li>
</ol>
<h5 id="2023517"><a class="markdownIt-Anchor" href="#2023517"></a> 2023.5.17.</h5>
<p>进一步学习了后缀数组的高度数组<code>height</code>并对<code>sa</code>做了详细笔记，要注意理解的是<code>sa</code>是<code>rk-&gt;i</code>，<code>rk</code>是<code>i-&gt;rk</code>，<code>height</code>是<code>rk-&gt;h</code>，求解实际问题中往往枚举的是后缀的排名<code>rk</code>，其实可以用不同的变量来提醒自己，而不要全部都用<code>i</code>，容易弄错。</p>
<ol start="69">
<li>UVA - 11107 - Life Forms - E2 - 多文本串查找最大公共(&gt;n/2)模式串<br />
由于sa只能处理一个字符串，所以我们可以考虑将字符串用不同的特殊字符(直接用256+id,id为文本串的编号,这样一定不会重复)连接起来得到大文本串T(长度为<code>N</code>)，加入特殊字符就是为了避免两个属于不同的文本串误当做一个模式串与其他文本串进行匹配了(因为有唯一的特殊字符,所以包含特殊字符的模式串一定无法和其他文本串进行匹配)。再结合<code>height</code>数组，我们可以很容易地得到多个文本串之间的公共子串长度(因为公共子串一定会出现在两个文本串后缀的LCP当中)；我们同样会得到同一个文本串内的公共子串，所以我们需要记录T的每个位置i对应的文本串<code>id</code>用<code>bel[i]</code>保存，和对应该文本串的后缀长度<code>len[i]</code>，用<code>flag[i]</code>记录文本串<code>i</code>是否包含当前LCP，如果<code>flag[i]</code>的个数<code>&gt;n/2</code>时，说明当前的LCP长度就是满足要求的。<br />
所以判断长度为<code>L</code>的前缀，可以通过贪心的方法，找一段连续的<code>height&gt;=L</code>的文本串个数(配合<code>flag[i]</code>，并且还需要用<code>bcnt</code>表示当前连续短的编号)，如果遇到<code>height&lt;L</code>说明当前连续块终止，<code>bcnt++</code>然后重置文本串计数器<code>tot</code>，于是<code>check(M)</code>函数的时间复杂度为<code>O(N)</code>。<br />
故可以用二分答案的方法求解最小的符合题意的前缀长度<code>L</code>，总时间复杂度<code>O(NlogM)</code>，其中<code>M</code>为单个文本串的最大长度。<br />
注意：本题查找的是至少大于一般的文本串中出现的子串，也就是<code>tot&gt;=n/2+1</code>，<code>tot</code>为当前串在全部文本串中出现的次数。</li>
</ol>
<h5 id="2023520"><a class="markdownIt-Anchor" href="#2023520"></a> 2023.5.20.</h5>
<p>划水了两天，弄大创浪费了好多时间～如果不能打难题，那打点水题其实也不错🐶</p>
<ol start="70">
<li>UVA - 12206 - Stammering Aliens - E3 - 求文本串中出现次数超过m次的最长子串<br />
后缀数组：类似前一题的方法，二分答案长度为<code>L</code>的公共长度，然后用<code>height[]</code>进行判断出现次数是否超过<code>m</code>，本题要求最右侧出现的位置，所以记得多次记录<code>max</code>值。<br />
注意：使用这种方法查找长度为<code>L</code>的公共子串的出现次数，一定要注意当<code>height[rk]&lt;L</code>时，是否有<code>n-sa[rk]&gt;=L</code>（也就是后缀长度大于等于<code>L</code>），这种情况就是<code>m=1</code>的时候会出现问题。<br />
本题的后缀数组做法还有另一种方法：需要发现一个有趣的性质，如果排名为<code>rk</code>的后缀有一个出现次数<code>&gt;=m</code>的前缀<code>t</code>，则<code>t</code>一定是<code>rk-m+1,...,rk</code>的前缀，所以问题就变成求数组<code>height[]</code>的窗口大小为<code>m-1</code>的区间最小值（滑动窗口，单调队列求解，一定要注意是长度为<code>m-1</code>，因为<code>height</code>是相邻后缀的前缀长度，所以<code>m=1</code>的时候必须特判，和二分方法要注意的问题相同），所有窗口的最小值中的最大值就是出现次数至少为<code>m</code>的最长的子串<code>ans1</code>，再用RMQ求<code>sa[rk-m+1,...,rk]</code>中的最大值就是<code>ans2</code>。<br />
注意：RMQ的<code>log</code>数组如果要使用则只需初始化一次<code>log[0]=log[1] = 0; for (int i = 0; i &lt; maxn; i++) log[i] = log[i&gt;&gt;1]+1;</code>，不然速度不如<code>while(1&lt;&lt;(k+1) &lt;= r-l+1) k++;</code>。<br />
Hash做法：和后缀数组第一种做法类似，二分答案<code>L</code>，然后将所有的长度为<code>L</code>的子串的Hash值全部提出来放到数组<code>hash[]</code>中，然后得到下标排序（将相同的Hash值放在一起），最后判断连续相同串的个数是否是大于等于<code>m</code>就行了。注意Hash基数的选取最好是素数。<br />
注意：由于<code>hash</code>,<code>rank</code>变量名和<code>std</code>中的重名了，所以可以选择删去<code>using namespace std;</code>，只需注意在使用<code>sort, max, min, queue, set...</code>的时候加上<code>std::</code>即可。</li>
</ol>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ULL<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">StrHash</span> <span class="token punctuation">&#123;</span>
    ULL n<span class="token punctuation">,</span> H<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> xp<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> x <span class="token operator">=</span> <span class="token number">2027</span><span class="token punctuation">;</span>
    <span class="token function">StrHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> xp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxn<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> xp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> xp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> x<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        n <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> H<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> H<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> H<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> x <span class="token operator">+</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    ULL <span class="token function">hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> H<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">-</span> H<span class="token punctuation">[</span>r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> xp<span class="token punctuation">[</span>r<span class="token operator">-</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>shash<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h5 id="2023521"><a class="markdownIt-Anchor" href="#2023521"></a> 2023.5.21.</h5>
<ol start="71">
<li>UVA - 11475 - Extend to Palindrome - Manacher模板题<br />
要将原串通过最短的填补得到回文串可以贪心的方法，最大化利用后缀的回文性质，也就是找到最大的后缀的回文串，然后将前面一段倒序输出在原串末尾即可。</li>
</ol>
<p>重新学习了一边SAM，用等价类的思想很容易搞清楚原理，但是构造的时间复杂度第二个<code>while</code>还是不会证明其线性性。</p>
<h5 id="2023522"><a class="markdownIt-Anchor" href="#2023522"></a> 2023.5.22.</h5>
<ol start="72">
<li>SPOJ - BEADS - Glass Beads - SAM模板题，长度为L字典序最小的子串<br />
一个串将自身开头放到结尾，那么就是将原串插入到SAM中两遍<code>T=S+S</code>，这样在DAG上得到的长度为L的字符串都是原串通过交换操作得到的结果，我们只用找到其中字典序最小的一个串记为<code>ans</code>，通过贪心每次找最小的字典序方向，<strong>最终停止的节点p对应的len[p]就是以该字符串为后缀的最右侧的终止位置</strong>，然后于是<code>len[p]-n+1</code>就是原串中交换操作停止的位置。<br />
5.23.发现问题：上文中加粗部分其实并不显然，需要利用到<code>T=S+S</code>和<code>ans</code>多次出现时相差部分的周期性。<br />
要证明上述加粗部分，只需证<code>T[1,...,len(p)]</code>的后缀包含<code>ans</code>，只需证<code>T[1,...,len(p)]</code>的endpos集合与<code>ans</code>的endpos集合相同。<br />
如果<code>ans</code>只在<code>T</code>中出现一次，显然成立，因为endpos中就一个元素，必然是<code>ans</code>结束的位置；假设<code>ans</code>在<code>T</code>中出现过多次（不妨令为2次），设其出现位置从左到右分别为<code>ans1,ans2</code>，那么<code>ans1</code>和<code>ans2</code>必然有交集（除非<code>S=ans</code>，这种情况结论同样成立），因为串长度为<code>L</code>，而<code>T</code>的长度就<code>2L</code>，而<code>ans2-ans1</code>的部分一定就是<code>ans</code>串的周期串<code>b</code>（证明和KMP找最小周期串相同），再发现<code>T=S+S</code>，所以<code>ans1</code>一定会和<code>T</code>中第二个<code>S</code>存在交集<code>a</code>，并且我们断言这个<code>a</code>就是<code>b</code>的后缀，如果不是，那么由于周期串的性质，<code>ans1</code>左侧一定还存在<code>ans</code>串，与<code>ans1</code>是最左侧的<code>ans</code>串矛盾；并且我们发现，第二个<code>S</code>的交集<code>a</code>正好就是第一个<code>S</code>与<code>ans1</code>的差，所以<code>a+ans1</code>的出现次数一定和<code>ans</code>的出现次数相同，我们又发现这个串是<code>T</code>的前缀，所以<code>a+ans1</code>就是<code>T[1,...,len(p)]</code>。<br />
<strong>QED</strong><br />
<img src="/figures/ACM/72.SPOJ-BEADS-Glass_Beads.jpg" srcset="/img/loading.gif" lazyload alt="72. SPOJ - BEADS - Glass Beads" /><br />
本题还有<strong>后缀数组</strong>的做法，类似的，将<code>T=S+S</code>加入到后缀数组中，然后从小到大查询后缀大小，如果该后缀长度<code>&gt;=L</code>，则说明找到答案，再利用<code>height</code>数组找到重复出现的最小的开头位置即为答案。</li>
<li>SPOJ - SUBST1 - New Distinct Substrings - 求不同的子串个数<br />
本题有两种方法：第一种是SAM的DAG图上的DP，另f(u)表示从u节点出发，能走出的路径数目，于是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>+</mo><msub><mo>∑</mo><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></msub><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><msub><mo stretchy="false">)</mo><mrow></mrow></msub></mrow><annotation encoding="application/x-tex">f(u) = 1+\sum_{(u,v)}f(v)_{}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.22471em;vertical-align:-0.47471em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.22528999999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">u</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.47471em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-1.85em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>表示节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo separator="true">,</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u,v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>之间有一条有向边），那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(0)-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>就是本题的解，也就是从根节点出发走出的所有的路径数。<br />
第二种是利用排除法，使用SA中的height数组，由于每个后缀的左端点两两不同，如果存在两个子串相同，那么相同的子串长度一定是某个<code>height</code>中记录过，这里每个<code>height</code>表示所有固定左端点，右端点一次递增的<code>height</code>个子串，我们只需要从<code>L*(L+1)/2</code>中删去所有的<code>height</code>值就可以得到两两不同的子串个数了。</li>
</ol>
<h5 id="2023523"><a class="markdownIt-Anchor" href="#2023523"></a> 2023.5.23.</h5>
<blockquote>
<p>总结了下SAM的算法模板，重新思考了时间复杂度问题，但仍然无法完美证明。大创总算结束了！</p>
</blockquote>
<h5 id="2023524"><a class="markdownIt-Anchor" href="#2023524"></a> 2023.5.24.</h5>
<blockquote>
<p>重写72题的后缀数组做法。</p>
</blockquote>
<ol start="74">
<li>第14届蓝桥杯国赛模拟赛A - 火柴棒数字 - 贪心<br />
每个数字消耗一定的火柴棍，火柴棍总数一定，求能拼出的最大数字。只需注意到相同数字肯定是位数越大越好，再是越大的数字往前排，贪心就行了。</li>
</ol>
<h5 id="2023525"><a class="markdownIt-Anchor" href="#2023525"></a> 2023.5.25.</h5>
<ol start="75">
<li>第14届蓝桥杯国赛模拟赛B - 火柴棒数字 - 模拟<br />
要求模拟12小时的钟表的两个指针的夹角大小，简单的做法应该就是枚举所有可行的时刻，计算出每个时刻<code>h:m:s</code>下的时针旋转角度<code>x=30h+m/2+s/120</code>，分针旋转角度<code>y=6m+s/10</code>，秒针<code>z=6s</code>，然后做差得到<code>A=min(|x-y|,360-|x-y|),B=min(|y-z|,360-|y-z|)</code>，一定要注意，两个时针的夹角要小于<code>180</code>，也就是说需要两个方向上夹角都算一遍取最小值，结果是<code>4 48 0</code></li>
<li>第14届蓝桥杯国赛模拟赛C - 最大公约数 - E4 - RMQ求区间gcd<br />
每次操作将相邻的两个元素其中一个换成两者的gcd，求将数组A全部变为1所需的最少次数。只需注意到：如果A中存在1，则直接贪心，就是最优解；如果A中没有1，则找到最短的区间其gcd为1，若该区间长度为L，则答案就是<code>n+L-2</code>。<br />
注意：RMQ细节还是很多的，以下为RMQ模板，给出了三处细节。</li>
</ol>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">int</span> maxn<span class="token operator">></span>
<span class="token keyword">struct</span> <span class="token class-name">RMQ</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> f<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">]</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token operator">*</span>A<span class="token punctuation">,</span> log<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// (1&lt;&lt;16) &lt;= n &amp;&amp; (1&lt;&lt;17) > n</span>
    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>A<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token operator">-></span>n <span class="token operator">=</span> n<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-></span>A <span class="token operator">=</span> A<span class="token punctuation">;</span>
        log<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> log<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> log<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> log<span class="token punctuation">[</span>i<span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 初始化数组枚举的长度是&lt;=n</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">void</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>j<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>j<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
                f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">gcd</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 构建f数组第三项i加长度后不用减1</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> k <span class="token operator">=</span> log<span class="token punctuation">[</span>r<span class="token operator">-</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">gcd</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>r<span class="token operator">-</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>k<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<ol start="77">
<li>第14届蓝桥杯国赛模拟赛
<ul>
<li>D - 出差 - E1 - Dijkstra<br />
最短路模板题，注意：记得双向边要<code>*2</code>边的个数，建议在maxm处就乘以2为好。</li>
<li>E - 卡牌 - E1 - 二分答案<br />
二分答案模板题，有个坑点，<code>m</code>的数据范围是<code>long long</code>。</li>
<li>F - 迷宫 - E6 - BFS<br />
很简单的题，但是就没注意到同一个点可能存在多个传送门，要用<code>vector</code>，而且不需要用<code>map</code>，就用数组即可，不然会超时。</li>
</ul>
</li>
</ol>
<h6 id="2023526"><a class="markdownIt-Anchor" href="#2023526"></a> 2023.5.26.</h6>
<ol start="78">
<li>第14届蓝桥杯国赛模拟赛 - H - E5 - 双指针<br />
看似简单但讨论不仔细很容易出错的题，令<code>l[r]</code>表示以<code>r</code>作为右端点向左的连续区间<code>[r-l[r]+1,r]</code>中每个<code>a[i]</code>都包含因子<code>g</code>的<strong>最大区间长度</strong>，如果<code>a[r]</code>不包含因子<code>g</code>，则<code>l[r]=0</code>。这样设的原因是我们想要考虑每次固定右端点<code>r</code>，讨论每次区间修改的元素，由于可以将修改的元素直接定为<code>g</code>，所以只需要连续区间都包含因子<code>g</code>即可。固定右端点<code>r</code>，讨论修改的元素：
<ol>
<li>修改<code>a[r]</code>：则<code>ans += l[r-1]</code>（无论<code>a[i]</code>是否包含因子<code>g</code>，都可以使得左侧以<code>a[r]</code>为右端点的连续区间<code>a[r-l[r],...,r]</code>都满足条件，总共有<code>l[r-1]</code>个）</li>
<li>若<code>a[i]</code>包含因子<code>g</code>，则我们可以修改<code>a[r-l[r-1]-1]</code>为<code>g</code>（左边第一个没有因子<code>g</code>的元素），并且如果它左侧还有连续区间，我们还能将其继续加上，于是当<code>r-l[r-1]-1&gt;=1</code>时（左侧存在一个没有因子<code>g</code>的元素），<code>ans += 1 + L[r-l[r-1]-2]</code>。</li>
</ol>
</li>
</ol>
<h5 id="2023527"><a class="markdownIt-Anchor" href="#2023527"></a> 2023.5.27.</h5>
<ol start="79">
<li>第14届蓝桥杯国赛模拟赛 - G - E? - 修路<br />
没有通过全部样例60分，DP方程想的有点怪：<code>f(i,j,k)</code>表示走完<code>A[1,...i]</code>和<code>B[1...j]</code>最后停在<code>k</code>处的最短路程（<code>k=0</code>停在<code>A</code>，<code>k=1</code>停在<code>B</code>），由于最开始要从<code>0</code>开始，所以我们将<code>A,B</code>从大到小排序，最后答案为<code>min&#123;f(n,m,0)+A[n], f(n,m,1)+B[m]&#125;</code>，转移方程是<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext> </mtext><munder><mo><mi>min</mi><mo>⁡</mo></mo><mrow><mn>1</mn><mo>⩽</mo><mi>k</mi><mo>&lt;</mo><mi>i</mi></mrow></munder><mi>f</mi><mo stretchy="false">(</mo><mi>k</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>A</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>A</mi><mi>i</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext> </mtext><mo>−</mo><mi>A</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><munder><mo><mi>min</mi><mo>⁡</mo></mo><mrow><mn>1</mn><mo>⩽</mo><mi>k</mi><mo>&lt;</mo><mi>i</mi></mrow></munder><mi>f</mi><mo stretchy="false">(</mo><mi>k</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>A</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext> </mtext><mo>−</mo><mi>A</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><mi>a</mi><mi>m</mi><mi>n</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
f(i,j,0) =&amp;\ \min_{1\leqslant k &lt; i} f(k, j, 1) + dis(k+1,j) + A_{k+1}-A_i\\
=&amp;\ -A[i] + \min_{1\leqslant k &lt; i} f(k,j,1) + dis(k+1,j) + A_{k+1}\\
=&amp;\ -A[i] + amn(i,j)
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.475554000000001em;vertical-align:-2.4877770000000003em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9877770000000003em;"><span style="top:-5.147777em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span></span><span style="top:-3.1599999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:-1.1722229999999998em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">=</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4877770000000003em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9877770000000003em;"><span style="top:-5.147777em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.66786em;"><span style="top:-2.347892em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mrel amsrm mtight">⩽</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">&lt;</span><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">min</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.847777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.1599999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.66786em;"><span style="top:-2.347892em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mrel amsrm mtight">⩽</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">&lt;</span><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">min</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.847777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.1722229999999998em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4877770000000003em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
其中使用<code>amn</code>表示<code>min</code>中的最小值，因为<code>min</code>中的式子与<code>i</code>无关，所以可以通过前面的计算结果给出<code>amn</code>，假如我们求出了<code>f(i,j,k)</code>，则<code>amn(i+1,j) = min&#123;amn(i+1,j), f(i,j,1) + dis(i+1,j) + A[i+1]&#125;</code>，对于<code>B</code>和<code>bmn</code>的讨论同理。<br />
这样DP的关键还有一个就是枚举顺序的问题，通过思考只需要从小到大枚举<code>i+j</code>即可，从数组上看就是每次斜着往后延拓一个长度。<br />
还有一个问题就是初始化，只需要初始化边界内容<code>f[1][j],f[i][1],amn[1][j],bmn[i][1]</code>即可。但是不清楚部分大数据过不了。</li>
<li>第14届蓝桥杯国赛模拟赛 - I - E1 - 背包与魔法<br />
在01背包的基础上加入一个可以将物品重量增加<code>K</code>，价值翻倍的魔法，只需对原来的01背包状态转移方程在增加一个维度用于记录是否使用过魔法，<code>f[i][j][k]</code>表示用前<code>i</code>个物品装<code>j</code>大小的背包并使用过<code>k=0,1</code>次魔法，转移上和01背包类似<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext> </mtext><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace width="1em"/><mi>j</mi><mo>&lt;</mo><msub><mi>w</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">{</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><msub><mi>w</mi><mi>i</mi></msub><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>+</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy="false">}</mo><mo separator="true">,</mo><mspace width="1em"/><mi>j</mi><mo>⩾</mo><msub><mi>w</mi><mi>i</mi></msub><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext> </mtext><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace width="1em"/><mi>j</mi><mo>&lt;</mo><msub><mi>w</mi><mi>i</mi></msub><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>max</mi><mo>⁡</mo><mo stretchy="false">{</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><msub><mi>w</mi><mi>i</mi></msub><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy="false">}</mo><mo separator="true">,</mo><mspace width="1em"/><msub><mi>w</mi><mi>i</mi></msub><mo>⩽</mo><mi>j</mi><mo>&lt;</mo><msub><mi>w</mi><mi>i</mi></msub><mo>+</mo><mi>K</mi><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>max</mi><mo>⁡</mo><mo stretchy="false">{</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><msub><mi>w</mi><mi>i</mi></msub><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><mi>K</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><msub><mi>v</mi><mi>i</mi></msub><mo stretchy="false">}</mo><mo separator="true">,</mo><mspace width="1em"/><msub><mi>w</mi><mi>i</mi></msub><mo>+</mo><mi>k</mi><mo>⩽</mo><mi>j</mi><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
f(i,j,0) =&amp;\ \begin{cases}
f(i-1,j,0),\quad j &lt; w_i,
\max\{f(i-1,j,0),f(i-1,j-w_i,0)+v_i\},\quad j \geqslant w_i.
\end{cases}\\
f(i,j,1) =&amp;\ \begin{cases}
f(i,j,0),\quad j &lt; w_i,\\
\max\{f(i,j,0), f(i-1,j-w_i,1)+v_i\},\quad w_i\leqslant j &lt; w_i + K,\\
\max\{f(i,j,0), f(i-1,j-w_i,1)+v_i, f(i-1,j-w_i-K,0) + 2v_i\},\quad w_i+k\leqslant j.
\end{cases}
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6.72002em;vertical-align:-3.11001em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.61001em;"><span style="top:-6.870010000000001em;"><span class="pstrut" style="height:4.41em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span></span><span style="top:-3.50999em;"><span class="pstrut" style="height:4.41em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.11001em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.61001em;"><span style="top:-6.870010000000001em;"><span class="pstrut" style="height:4.41em;"></span><span class="mord"><span class="mord"></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9699999999999999em;"><span style="top:-2.9699999999999998em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">max</span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩾</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4700000000000001em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.50999em;"><span class="pstrut" style="height:4.41em;"></span><span class="mord"><span class="mord"></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35002em;"><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.19499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.20499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.2950099999999996em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.30501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.8500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mop">max</span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span></span></span><span style="top:-1.5300000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mop">max</span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mord">.</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.9099999999999997em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.11001em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
</li>
<li>SPOJ - LCS - Longest Common Substring - E2 - 最长公共子串<br />
本题还是可以使用SA的做法，与69题一样，时间复杂度O(LlogL)。<br />
使用SAM，将第一个串插入到SAM中，对于第二个串的每个字符<code>c</code>，在其中查找<code>next[p][c]</code>是否存在，存在则跳转<code>p=next[p][c]</code>，并且当前长度<code>l++</code>，如果找不到则跳转<code>link[p]</code>边，并将<code>l=len[p]</code>因为当前后缀一定包含<code>len[p]</code>的长度的后缀，所以<code>len[p]</code>一定是在当前搜索串中的后缀（类似AC自动机的操作，只不过这里不是完全匹配，而是最大后缀匹配，<code>l</code>就是当前的最大后缀匹配长度），我们可以证明跳转<code>p</code>的次数一定不超过第二个串的长度<code>O(|B|)</code>：<br />
这是因为当前SAM中的节点p对应的字符串集合中一定包含长度为<code>l</code>的后缀，由于<code>l</code>增加的次数最多为<code>|B|</code>次，而每次跳转<code>p=link[p]</code>会使得<code>l</code>的大小至少减少<code>1</code>，所以总跳转次数一定<code>&lt;=|B|</code>。（类似SAM中第一个<code>while</code>循环的次数不超过<code>n</code>次）</li>
<li>HDU - 4622 - Reincarnation - E2 - 判断不同的子串数目<br />
用SAM的最后插入节点的<code>len[cur]-len[link[cur]]</code>可以得到<code>s[1,...,r-1]</code>变化到<code>s[1,...,r]</code>的不同子串数目，所以只要求前缀和就可以得到<code>s[1,...,r]</code>中的所有不同子串数目，进一步如果每次修改起始节点<code>l=1,2,...</code>，然后重启SAM，用类似的方法，从而可以得到<code>s[l,...,r]</code>中的所有不同子串数目。</li>
</ol>
<h5 id="2023528"><a class="markdownIt-Anchor" href="#2023528"></a> 2023.5.28.</h5>
<p>总算考完微分几何了，休息了一下下。</p>
<h5 id="2023529"><a class="markdownIt-Anchor" href="#2023529"></a> 2023.5.29.</h5>
<ol start="92">
<li>SPOJ - NSUBSTR - Substrings - E2 - 求长度一定的子串的出现次数（SAM求后缀链接树DFS）<br />
在SAM一个endpos节点<code>p</code>存储的字符串长度就是<code>len[p]-len[link[p]]</code>，节点<code>p</code>的endpos集合大小就是每次其中存储的每个子串的出现次数（以endpos相同定义的等价类），所以首先可以通过DFS后缀链接树、或者根据<code>len</code>数组排序，从大到小枚举节点，计算出<code>endpos</code>大小（在子串插入节点处初始化<code>endpos[cur] = 1</code>），然后假设<code>f[l]</code>表示长度为<code>l</code>的子串对应的<code>endpos</code>集合大小，则<code>f[len[link[p]]+1,...,len[p]] &lt;-max- endpos[p]</code>将<code>endpos[p]</code>与左侧给出的那些<code>f</code>取<code>max</code>，我们注意到大的串长度一定包含短串，所以我们只需要对<code>f[len[p]]</code>更新，然后从大到小更新<code>f[i] = max(f[i], f[i+1])</code>就可以得到上述效果。<br />
下面使用基数排序对<code>len</code>进行排序，其中<code>la[i]</code>表示<code>len[]</code>数组中的第<code>i</code>大元素对应的编号。</li>
</ol>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> c<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> la<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 与SA基数排序相同，c[]为桶，la为len array，从rk值对应到id</span>
<span class="token keyword">void</span> <span class="token function">toposort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">resetn</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> c<span class="token punctuation">[</span>len<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> c<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 由于len[i]的值域范围一定小于sz，所以可以将sz作为桶大小</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> sz<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> la<span class="token punctuation">[</span><span class="token operator">--</span>c<span class="token punctuation">[</span>len<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>  <span class="token comment">// sz为桶大小</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h5 id="2023530"><a class="markdownIt-Anchor" href="#2023530"></a> 2023.5.30.</h5>
<ol start="93">
<li>HDU - 4436 - str2int - E3 - 广义SAM模板题（只用到DAG图）<br />
本题就是要同时处理多个文本串，SAM处理多个字符串有两种做法，第一个和后缀数组类似，就是在每个文本串末尾加入分隔符；第二种是广义SAM，就是一个SAM中同时插入多个字符串，其实方法很简单，只需在每次插入新串前重置<code>last = 0</code>，插入串的字符<code>c</code>时，判断是否当前插入的节点已经在SAM中有对应节点，如果已有则将<code>last</code>直接转移过去，否则类似创建<code>nq</code>节点，从<code>q</code>节点中分裂出后缀长度小于等于<code>len[p]+1</code>部分的子串，除了不用将<code>link[cur]</code>设置为<code>nq</code>其他与之前完全一致，这里引入<code>split</code>函数，只需要对<code>insert(char c)</code>函数进行修改：</li>
</ol>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">,</span> <span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> nq <span class="token operator">=</span> <span class="token function">new_node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">copy</span><span class="token punctuation">(</span>next<span class="token punctuation">[</span>nq<span class="token punctuation">]</span><span class="token punctuation">,</span> next<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    link<span class="token punctuation">[</span>nq<span class="token punctuation">]</span> <span class="token operator">=</span> link<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">;</span> len<span class="token punctuation">[</span>nq<span class="token punctuation">]</span> <span class="token operator">=</span> len<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> link<span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token operator">=</span> nq<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> link<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> nq<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> next<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">==</span> q<span class="token punctuation">)</span> next<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> nq<span class="token punctuation">,</span> p <span class="token operator">=</span> link<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> nq<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    c <span class="token operator">=</span> <span class="token function">id</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> p <span class="token operator">=</span> last<span class="token punctuation">,</span> np <span class="token operator">=</span> next<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>np<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>len<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span> <span class="token operator">==</span> len<span class="token punctuation">[</span>np<span class="token punctuation">]</span><span class="token punctuation">)</span> last <span class="token operator">=</span> np<span class="token punctuation">;</span>
        <span class="token keyword">else</span> last <span class="token operator">=</span> <span class="token function">split</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> p<span class="token punctuation">,</span> np<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token function">new_node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    len<span class="token punctuation">[</span>last <span class="token operator">=</span> cur<span class="token punctuation">]</span> <span class="token operator">=</span> len<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>next<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span> next<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> cur<span class="token punctuation">,</span> p <span class="token operator">=</span> link<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> link<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
    <span class="token keyword">int</span> q <span class="token operator">=</span> next<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>len<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">==</span> len<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> link<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">;</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
    <span class="token function">split</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">,</span> cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h5 id="2023531"><a class="markdownIt-Anchor" href="#2023531"></a> 2023.5.31.</h5>
<ol start="94">
<li>HDU - 6704 - K-th occurrence - 后缀链接树倍增+线段树合并处理endpos集合<br />
本题是要求文本串<code>T</code>的子串<code>T[l,...,r]</code>在<code>T</code>中的第<code>K</code>次出现次数，首先很容易想到在后缀链接树上倍增求出<code>T[l,...,r]</code>所处的endpos节点（方法就是记录下每个字符串结束位置<code>T[0,...,r]</code>对应的SAM节点<code>pos[r]</code>，然后从<code>pos[r]</code>出发，在后缀链接树上倍增找祖先节点<code>u</code>中满足<code>len[u]&gt;=r-l+1</code>最浅的节点），本题还要求SAM中节点的endpos集合中的第K大元素，那么如何处理endpos集合呢？考虑利用线段树进行维护，我们不用每次重建整棵树，而是对线段树进行合并（类似动态开点，但这里不能使用new节点，因为一个父节点可能存在多个儿子节点，儿子节点之间可能有重合边，而更新父节点时候如果重复更新一条边会将多余的点进行抛弃，这就会导致内存泄漏的问题，因为不清楚那些节点要删去），这里用一个数组记录下来，然后新节点就是在数组上继续向后取值。那么又有最后一个问题：时间复杂度计算已经在<a href="/posts/12920/#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97">字符串相关算法中 - SAM - 维护endpos集合</a>中给出。复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\mathcal{O}(n\log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span></span></span></span>常数较大，且空间要开到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi><mi>log</mi><mo>⁡</mo><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">2n\log 2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord mathnormal">n</span></span></span></span>，本题还有后缀数组做法，见明天的笔记。</li>
<li>洛谷 - P3834 - 可持久化线段树 2 - E5<br />
可持久化线段树模板题，就是一种每个位置上用动态开点构建权值线段树，已在线段树笔记中描述细节。</li>
</ol>
<h5 id="202361"><a class="markdownIt-Anchor" href="#202361"></a> 2023.6.1.</h5>
<ol start="94">
<li>HDU - 6704 - K-th occurrence - 后缀数组RMQ+二分+可持久化线段树<br />
这是查询子串<code>T[l,...,r]</code>第<code>K</code>次出现次数的另一种做法，我们有了所有后缀的排序，于是当前<code>T[l,...,r]</code>的子串一定出现在第<code>l</code>个后缀当中，所以我们从<code>rank[l]</code>开始，在排好序的后缀中向上找最小的<code>L&lt;=rank[l]</code>使得<code>(L,rank[l]]</code>中的<code>height</code>数组大小均<code>&gt;=len</code>（二分+在height数组上构建RMQ做check函数）；同理，还要找到<code>R&gt;=rank[l]</code>最大的<code>R</code>使得<code>[rank[l],R)</code>的<code>height</code>数组大小均<code>&gt;=len</code>。于是我们就得到了子串出现的后缀对应的排名：<code>[L,...,R]</code>，最后要求出第<code>K</code>大位置，那么我们就构建根据<code>sa[]</code>数组构建可持久化权值线段树（已记录<a target="_blank" rel="noopener" href="https://wty-yy.space/posts/48555/">可持久化线段树笔记</a>），在<code>root[R],root[L-1]</code>两颗线段树之差上进行查找第<code>K</code>大元素就OK了。<br />
SA的常数(1.8s,33.2Mb)一般都比SAM(2.3s,104.1Mb)要小的多，而且代码量上近似，只要有好的基本功，分别实现完每个算法最后拼接起来即可。</li>
</ol>
<h5 id="202363"><a class="markdownIt-Anchor" href="#202363"></a> 2023.6.3.</h5>
<p>复习计划2：</p>
<ul>
<li>[x] 基础计数</li>
<li>[ ] 递推关系</li>
<li>[x] 二维几何基础</li>
<li>[ ] 二维几何常用算法</li>
<li>[x] 凸包</li>
</ul>
<ol start="95">
<li>UVA - 11538 - Chess Queen<br />
在<code>n*m</code>的棋盘上放2个不同颜色的皇后，有多少种冲突的方法。基础题，只需要分别讨论三种冲突方法，分别为水平方向，竖直方向，两种斜线方向，然后将三者进行求和即可。</li>
</ol>
<h5 id="202364"><a class="markdownIt-Anchor" href="#202364"></a> 2023.6.4.</h5>
<ol start="96">
<li>UVA - 11401 - Triangle Counting<br />
统计用长度为<code>1,...,n</code>的边，不重复地选出三条边拼成不同的三角形的个数。
<ol>
<li>首先固定其中最长的一条边长<code>x</code>，则由三角形公式<code>y+z&gt;x</code>，可得<code>x-y&lt;z&lt;x</code>，则<code>y=1,2,...,x-1</code>时，<code>z</code>的选择个数有<code>0,1,...,x-2</code>。</li>
<li>注意还要求<code>y!=z</code>，且不要重复记录三角形（上述计数方法每个三角形重复记录了两遍，所以最后还要<code>/2</code>），要求<code>y!=z</code>也就是去除<code>y=z</code>的情况，不难发现<code>y=z</code>时，<code>x/2&lt;z&lt;x</code>，等价于，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mfrac><mrow><mi>x</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[\frac{x+1}{2}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mopen">[</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">]</span></span></span></span></li>
</ol>
</li>
</ol>
<h5 id="202365"><a class="markdownIt-Anchor" href="#202365"></a> 2023.6.5.</h5>
<ol start="97">
<li>UVA - 11806 - Cheerleaders<br />
在<code>m*n</code>的网格图中放<code>k</code>个石子，并要求最外的一层上至少有一个石子的方案数。这种问题解决方法就是将**“至少一个”转化为“全集 - 任意一个都没有”**，没有任何限制条件的全集记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>，设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>表示第1行没有一个石子，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>表示第<code>m</code>行没有一个石子，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>表示第1列没有一个石子，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>表示第<code>n</code>列没有一个石子，于是总方案数就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mo>−</mo><mi mathvariant="normal">∣</mi><mi>A</mi><mo>∩</mo><mi>B</mi><mo>∩</mo><mi>C</mi><mo>∩</mo><mi>D</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|S| - |A\cap B \cap C\cap D|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">∣</span></span></span></span>，而求解第二项就用容斥原理即可。<br />
这里给出一个较为容易的方式实现容斥原理，因为容斥原理就是对于每个性质是否进行选择，并根据选择性质的个数确定正负号，而且枚举的总个数正好就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>表示性质的类别个数，于是可以使用二进制枚举，范围为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∼</mo><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0\sim 2^k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，二进制中第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>为1表示选择第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>个性质，于是二进制中1的个数表示选择性质的总个数，通过其判断符号的正负。</li>
</ol>
<h5 id="202366"><a class="markdownIt-Anchor" href="#202366"></a> 2023.6.6.</h5>
<ol start="98">
<li>UVA - 11178 - Morley’s Theorem<br />
几何计算题，只需分别实现向量夹角<code>angle(u, v)</code>，向量逆时针旋转<code>rotate(u, rad)</code>和计算直线交点<code>line_intersection(A, u, B, v)</code>。</li>
<li>UVA - 1342 - That Nice Euler Circuit - E2 - 平面图中的Euler定理<br />
二维平面图的顶点数V、边数E和面数F满足欧拉定理：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>+</mo><mi>F</mi><mo>=</mo><mn>2</mn><mo>+</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">V+F=2+E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>，这个定理的证明很有意思，要用到对偶图，以及分别在对偶图上建立对偶生成树（已做笔记）。根据欧拉定理就很容易给出结果，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>=</mo><mn>2</mn><mo>+</mo><mi>E</mi><mo>−</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">F = 2+E-V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>，现在就要求出图中所有的顶点（包括两边的交点，并且要去重），再通过顶点求边数（如果一个顶点在一条边的内部，则这个点能划分出新的一条边），所以我们只需要分别实现<code>segment_proper_intersection(A1,A2,B1,B2)</code>判断两个线段<code>A1A2</code>和<code>B1B2</code>是否正规相交（即线段的内部有交点），以及<code>on_segment(P,A,B)</code>判断<code>P</code>是否在线段<code>AB</code>的内部。</li>
</ol>
<h5 id="202368"><a class="markdownIt-Anchor" href="#202368"></a> 2023.6.8.</h5>
<ol start="100">
<li>UVA - 11796 - Dog Distance - 相对运动距离计算<br />
要求两个折线段的最近距离和最远距离，从每个单独的线段上看，两个在线段上运动的质点之间的相对位移一定是直线段，所以我们考虑固定A点，然后移动B点然后将问题转化为A点到B的移动线段的最短距离，这样就得到了最短距离，而最远距离一定在端点处取到。每次以两个点首先运动到拐点的一个点作为终止，所以总共时间复杂度就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">P</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>A</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>B</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}(|A|+|B|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span></span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal">A</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>.<br />
只需实现<code>distance2line(P,A,B)</code>点<code>P</code>到直线<code>AB</code>距离，和<code>distance2segment(P,A,B)</code>点<code>P</code>到线段<code>AB</code>距离。</li>
<li>UVA - 10652 - Board Wrapping - 凸包模板题<br />
计算出每个矩形的四个点，然后求出凸包，最后求凸包围成的面积即可。需要实现<code>convex_hull(P,n,hull)</code>计算大小为<code>n</code>的点集<code>P</code>构成的凸包<code>hull</code>和利用三角划分求出多边形的有向面积（以逆时针方向为正向）。</li>
</ol>
<h5 id="2023610"><a class="markdownIt-Anchor" href="#2023610"></a> 2023.6.10.</h5>
<p>今天打完了2023年蓝桥杯决赛，感觉还行，总共10题，完整做出了6题，其中一个是树形dp（需要维护每个节点的深度为1，2的前三大权重和（利用一个<code>Max</code>结构体，内部套一个<code>Node</code>结构体，记录<code>id</code>和权重<code>w</code>），分4种情况对答案进行更新），还有一个是SAM模板题（分别统计出现次数为<code>1,...,L</code>的不同子串的个数，<code>L</code>为文本串长度，只需要求出每个节点的endpos大小，然后利用<code>len[p]-len[link[p]]</code>为节点<code>p</code>对应的子串集合大小这个性质对答案进行累加求和即可<code>ans[endpos[p]] += len[p]-len[link[p]]</code>），前两道填空题自认为蛮难，但都有思路（一个dp，一个要用bitset模拟的快速幂），倒数第二题暴力骗了点分，应该是点分治的题，应该要复习下了。<br />
比较可惜的是一个简单题还没想出来，给两个数组<code>A,B</code>长度分别为<code>n,m</code>，设数组<code>C=&#123;A[i]+B[j]:i,j&#125;</code>，求<code>C</code>中第<code>K</code>大值，范围是<code>n,m&lt;=1e5</code>。</p>
<h5 id="2023612"><a class="markdownIt-Anchor" href="#2023612"></a> 2023.6.12.</h5>
<ol start="102">
<li>UVA - 11168 - Airport - 凸包+点到直线距离<br />
也是凸包模板题，题目要求的直线一定是凸包上的某一条边，若直线方程为Ax+By+C=0，则点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>到直线距离为<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …{\sqrt{A^2+B^2}'>\frac{|Ax+By+C|}{\sqrt{A^2+B^2}</span>，然后由于所有点均在直线的一边，所以绝对值要么全部为正要么为负，所以直接记录<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><mi>x</mi><mo separator="true">,</mo><mo>∑</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">\sum x,\sum y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>，然后直接求出所有点到直线的平均距离，逐一枚举，取最小者即可。<br />
注意：判断凸包时点集合大小至少为2，所以需要特判只有1个点的情况，输出保留3位小数，所以要输出<code>0.000</code>。</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/coding/" class="category-chain-item">coding</a>
  
  
    <span>></span>
    
  <a href="/categories/coding/algorithm/" class="category-chain-item">algorithm</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>2023算法复习</div>
      <div>https://wty-yy.xyz/posts/35639/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>wty</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年5月7日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/12920/" title="字符串相关算法">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">字符串相关算法</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/35891/" title="ARC159 - AtCoder Regular Contest 159">
                        <span class="hidden-mobile">ARC159 - AtCoder Regular Contest 159</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.16/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"7JWUOvcOubbTCSI8jHpuVSJ0-gzGzoHsz","appKey":"98rYU3iGXuuKPVyUjNYHGpr9","path":"window.location.pathname","placeholder":"说点什么","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":true,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <br> Enjoy sharing! <br> <span id="runtime_span"></span> <script type="text/javascript">function show_runtime(){window.setTimeout("show_runtime()",1000);X=new Date("3/19/2021 00:00:00");Y=new Date();T=(Y.getTime()-X.getTime());M=24*60*60*1000;a=T/M;A=Math.floor(a);b=(a-A)*24;B=Math.floor(b);c=(b-B)*60;C=Math.floor((b-B)*60);D=Math.floor((c-C)*60);runtime_span.innerHTML="小站已运行"+A+"天"+B+"小时"+C+"分"+D+"秒"}show_runtime();</script> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script  src="https://lib.baomitu.com/prism/1.26.0/plugins/line-numbers/prism-line-numbers.min.js" ></script>

  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>




  
<script src="//fastly.jsdelivr.net/gh/bynotes/texiao/source/js/caidai.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
